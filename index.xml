<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Botmaster Documentation</title>
    <link>https://botmasterai.github.io/index.xml</link>
    <description>Recent content on Botmaster Documentation</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>MIT</copyright>
    <lastBuildDate>Sat, 29 Oct 2016 17:09:45 +0100</lastBuildDate>
    <atom:link href="https://botmasterai.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Getting started</title>
      <link>https://botmasterai.github.io/getting-started/</link>
      <pubDate>Sat, 29 Oct 2016 17:09:45 +0100</pubDate>
      
      <guid>https://botmasterai.github.io/getting-started/</guid>
      <description>

&lt;h1 id=&#34;getting-started&#34;&gt;GETTING STARTED&lt;/h1&gt;

&lt;h3 id=&#34;installation-installation&#34;&gt;&lt;a href=&#34;installation&#34;&gt;Installation&lt;/a&gt;&lt;/h3&gt;

&lt;h3 id=&#34;quickstart-quickstart&#34;&gt;&lt;a href=&#34;quickstart&#34;&gt;Quickstart&lt;/a&gt;&lt;/h3&gt;

&lt;h3 id=&#34;getting-set-up-getting-set-up&#34;&gt;&lt;a href=&#34;getting-set-up&#34;&gt;Getting set up&lt;/a&gt;&lt;/h3&gt;

&lt;h3 id=&#34;facebook-messenger-setup-messenger-setup&#34;&gt;&lt;a href=&#34;messenger-setup&#34;&gt;Facebook Messenger Setup&lt;/a&gt;&lt;/h3&gt;

&lt;h3 id=&#34;slack-setup-slack-setup&#34;&gt;&lt;a href=&#34;slack-setup&#34;&gt;Slack Setup&lt;/a&gt;&lt;/h3&gt;

&lt;h3 id=&#34;socket-io-setup-socketio-setup&#34;&gt;&lt;a href=&#34;socketio-setup&#34;&gt;Socket.io Setup&lt;/a&gt;&lt;/h3&gt;

&lt;h3 id=&#34;twitter-setup-twitter-setup&#34;&gt;&lt;a href=&#34;twitter-setup&#34;&gt;Twitter Setup&lt;/a&gt;&lt;/h3&gt;

&lt;h3 id=&#34;telegram-setup-telegram-setup&#34;&gt;&lt;a href=&#34;telegram-setup&#34;&gt;Telegram setup&lt;/a&gt;&lt;/h3&gt;

&lt;h3 id=&#34;webhooks-webhooks&#34;&gt;&lt;a href=&#34;webhooks&#34;&gt;Webhooks&lt;/a&gt;&lt;/h3&gt;
</description>
    </item>
    
    <item>
      <title>Fulfill</title>
      <link>https://botmasterai.github.io/official-middleware/fulfill/</link>
      <pubDate>Wed, 28 Dec 2016 17:31:40 +0000</pubDate>
      
      <guid>https://botmasterai.github.io/official-middleware/fulfill/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;botmaster-fulfill&lt;/strong&gt; provides a text-friendly way to integrate actions with your bot. You supply an object of action-functions that can return synchronously or asynchronously and replace text in the response, generate new responses, or do what the response claims to do, by for example actually placing the users burger order for him using a REST API.&lt;/p&gt;

&lt;!-- TOC depthFrom:1 depthTo:2 withLinks:1 updateOnSave:1 orderedList:0 --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#markup-for-your-chatbot&#34;&gt;Markup for your chatbot.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#quick-start&#34;&gt;Quick start&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#introduction&#34;&gt;Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#how-to-use-the-fulfill-api&#34;&gt;How to use the Fulfill API&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#format-for-the-action-spec&#34;&gt;Format for the action spec&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#more-info-on-params&#34;&gt;More info on params:&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#additional-controller-configuration-options&#34;&gt;Additional controller configuration options&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#using-botmaster-fulfill&#34;&gt;Using botmaster-fulfill&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#additional-middleware-options&#34;&gt;Additional middleware options&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#using-standalone-without-botmaster&#34;&gt;Using standalone without botmaster&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#setup-hint-drag-and-drop-action-modules&#34;&gt;Setup hint - drag and drop action modules&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#debug&#34;&gt;Debug&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- /TOC --&gt;

&lt;h1 id=&#34;markup-for-your-chatbot&#34;&gt;Markup for your chatbot.&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt; Chabot: &amp;quot;Let me see if I can place your order, &amp;lt;pause /&amp;gt; &amp;lt;placeOrder id=12 /&amp;gt;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You just built a chatbot. Its funny, and it says useful stuff. But how do you get it to do something?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;Shaquille O&#39;Neal: Little man, I ordered tomatoes on this Good Burger, and I don&#39;t see no tomatoes!

Ed: Well, hang on... &amp;lt;modifyOrder style=&#39;slap&#39;&amp;gt;Tomatoes&amp;lt;/modifyOrder&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Good Burger, Brian Robbins (1997)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Fulfill makes this easy with declarative markup that is easy to understand for non-technical chat authors and is easy to integrate into your current botmaster stack.&lt;/p&gt;

&lt;p&gt;Available on npm:
&lt;a href=&#34;https://www.npmjs.com/package/botmaster-fulfill&#34;&gt;https://www.npmjs.com/package/botmaster-fulfill&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;quick-start&#34;&gt;Quick start&lt;/h1&gt;

&lt;p&gt;All you need to get started.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;npm install botmaster-fulfill --save
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const {outgoing} = require(&#39;botmaster-fulfill&#39;);
const Botmaster = require(&#39;botmaster&#39;);
const botsSettings = require(&#39;./my-bots-settings&#39;);
const botmaster = new Botmaster({botsSettings});
const actions = {
        hi: {
            controller: () =&amp;gt; &#39;hi there!&#39;
        }
}
botmaster.use(&#39;outgoing&#39;, outgoing({actions}));
botmaster.on(&#39;update&#39;, bot =&amp;gt; bot.sendMessage(&#39;&amp;lt;hi /&amp;gt;&#39;));
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;botmaster-fulfill extends botmaster with a repertoire of actions that your bots can perform with a declarative and easy to use syntax based on XML. It is a great way to separate business logic (when to do what and where) and functional logic (how to do it).&lt;/p&gt;

&lt;p&gt;When writing the output of your bots all you have to do is write:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;ok &amp;lt;userName /&amp;gt;, im placing your order for you. &amp;lt;placeOrder /&amp;gt; here you go. &amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here &lt;strong&gt;userName&lt;/strong&gt; could for example mean get a human readable version of the audience&amp;rsquo;s name.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;placeOrder&lt;/strong&gt;  does two much more interesting things and demonstrates the power of using markup over a simple field-based JSON payload. First, it sends the rest of the message before the tag (&amp;ldquo;ok bob, I&amp;rsquo;m placing your order for you.&amp;rdquo;) onwards so that the user knows we are placing his order. Second, it starts placing the order and when its done, it sends the text following it, &amp;ldquo;here you go.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;And in order to connect that all you have to do is write in plain js:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const actions = {
    // for &amp;lt;userName /&amp;gt;
    userName: {
        controller: function(params) {
            // return a promise (using an imaginary getUser method)
            return getUser(params.context.user)
                .then( function(result) {
                    return result.user.name
                    // if name is &amp;quot;bob&amp;quot; then the text would be
                    // &amp;quot;ok bob, I&#39;m placing your oder for you.&amp;quot;
                });
        }
    },
    // for &amp;lt;placeOrder /&amp;gt;
    placeOrder: {
        // replace not just the tag, but the text after too
        replace: &#39;after&#39;,
        controller: function(params) {
            placeOrder(params.context.order)
                .then( function(result) {
                    // once the order is placed then send the rest of the message
                    params.sendMessage(params.after)
                });
            // remove the tag and the text after it and send the message (&amp;quot;ok bob, I&#39;m placing your order for you.&amp;quot;)
            return &#39;&#39;;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;how-to-use-the-fulfill-api&#34;&gt;How to use the Fulfill API&lt;/h1&gt;

&lt;p&gt;You use fulfill by specifying an action spec. At a minimum your spec must specify controller as a javascript function that can return either by callback, promise or even synchronously. The action controller receives a params object which it can use as parameters such as the contents of the tag or data about the chat, which is stored in a variable called context. It can update the context and its return value will replace the tag. If the returned value from an action includes another action, this action will also be evaluated.&lt;/p&gt;

&lt;p&gt;Once fulfill has finished evaluating or actions you get back an updated response string and any context passed in has been modified in place.&lt;/p&gt;

&lt;h2 id=&#34;format-for-the-action-spec&#34;&gt;Format for the action spec&lt;/h2&gt;

&lt;p&gt;You should provide an &lt;strong&gt;actions&lt;/strong&gt; object where the key is the name of the xml element that will be matched. The value should specify another object that has the key &lt;strong&gt;controller&lt;/strong&gt; which as a value should have a function that takes &lt;strong&gt;params&lt;/strong&gt; and an optional callback.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const actions = {
// sync &amp;lt;burgerImage /&amp;gt; example
  burgerImage: {
    controller: function() {
      return &amp;quot;&amp;lt;img url=&#39;some/complex/static/path/burger.png&#39;&amp;gt;&amp;quot;;
    }
  },
// error first callback &amp;lt;modifyOrder style=&#39;someStyle&#39;&amp;gt;Stuff to order&amp;lt;/modifyOrder&amp;gt;
  modifyOrder: {
    controller: function(params, cb) {
      myOrderAPI.modify(params.context.orderId, params.content, params.attributes.style, function(err) {
        if (! err) {
          cb(null, &amp;quot;There, consider yourself tomatoed!&amp;quot;);
        } else {
          cb(null, &amp;quot;Sorry I can&#39;t modify your order now. Please check again later&amp;quot;)
        }
        });
    }
  },
// promise example
  hi: {
    controller: function(params) {
        return new Promise(function(resolve, reject) {
          resolve(&amp;quot;hello world&amp;quot;);
        });
    }
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;more-info-on-params&#34;&gt;More info on params:&lt;/h2&gt;

&lt;p&gt;Params argument provides several variables that can control its behavior.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;params.context&lt;/strong&gt;: a reference to the context object which can be updated or read&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;params.content&lt;/strong&gt;: the literal text between the xml element opening and closing&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;params.attributes&lt;/strong&gt;: an object where keys are the name of an attribute against the xml element and the the value is the value of that attribute.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;params.after&lt;/strong&gt;: the text immediately following the tag, up to another tag.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;params.before&lt;/strong&gt;: the text immediately preceding the tag, up to another tag.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;suggested-context-setup&#34;&gt;Suggested context setup:&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;context&lt;/strong&gt; provides a great deal of control and allows you to pass custom dependencies down to your controllers.
It should not be confused with the &lt;strong&gt;context&lt;/strong&gt; variable that your NLU like IBM Conversations uses.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s a good setup for context that will allow your actions a great deal of flexibility:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const context = {
    chatContext, // specific to your NLU
    apis // configured APIs connector libraries to call in your actions
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To configure this in your middleware:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;botmaster.use(&#39;outgoing&#39;, outgoing({actions, context}))
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;where-did-my-nlu-context-go&#34;&gt;Where did my NLU context go?&lt;/h3&gt;

&lt;p&gt;In botmaster the fulfill context will also have &lt;strong&gt;context.update&lt;/strong&gt; available. To get an NLU&amp;rsquo;s context the update handler or one of the middleware&amp;rsquo;s should have set it in &lt;strong&gt;update&lt;/strong&gt;. So for example your context might be in &lt;strong&gt;context.update.context&lt;/strong&gt;.&lt;/p&gt;

&lt;h3 id=&#34;getting-impatient-emitting-updates-before-fulfill-has-completed&#34;&gt;Getting impatient - emitting updates before fulfill has completed&lt;/h3&gt;

&lt;p&gt;You might want to cascade messages and separate them by one minute pauses. Or you want to let your user know that you are working on it. Whatever your use case, emitting multiple updates is not a problem. In botmaster you will also have available &lt;strong&gt;context.bot.sendMessage&lt;/strong&gt; which you can use to send another template response down the pipeline. This will be processed again by fulfill since fulfill is part of the outgoing middleware stack. This is actually advantageous because this way you can be sure that there are no further actions to fulfill from the emitted message.&lt;/p&gt;

&lt;p&gt;If you are not using botmaster you can achieve the same thing by including in the context an emitter which should set off a handler that calls fulfill.&lt;/p&gt;

&lt;h2 id=&#34;additional-controller-configuration-options&#34;&gt;Additional controller configuration options&lt;/h2&gt;

&lt;p&gt;By default, an action modifies the response text by replacing the xml tag with its response inline. This allows multiple actions in a response to not conflict. Note that this default does not allow you to modify any text surrounding the tag.&lt;/p&gt;

&lt;p&gt;Take the following example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;optional /&amp;gt; hi how are &amp;lt;you /&amp;gt; today?
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With the default mode you can only replace the tag. There are however other modes available that allow you to modify surrounding text.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;action.replace&lt;/strong&gt;:
1. &lt;strong&gt;= &amp;lsquo;before&amp;rsquo;&lt;/strong&gt; Replace the tag and text before the tag until another tag is reached. In the example above setting &lt;strong&gt;you&lt;/strong&gt; to this mode will have the controller control up to &lt;strong&gt;hi how are &lt;you /&gt;&lt;/strong&gt;.
2. &lt;strong&gt;= after&lt;/strong&gt; Replace the tag and text after the tag until another tag is reached. In the example above setting &lt;strong&gt;after&lt;/strong&gt; to this mode will set the controller to control &lt;strong&gt;&lt;optional /&gt; hi how are you&lt;/strong&gt;.
3. &lt;strong&gt;= adjacent&lt;/strong&gt; Replace the tag and text before and after the tag until other tags are reached. In the example above setting &lt;strong&gt;you&lt;/strong&gt; to this mode will set the controller to control &lt;strong&gt;hi how are &lt;you /&gt; today ?&lt;/strong&gt;.
4. &lt;strong&gt;= replaceFunction($, responses)&lt;/strong&gt; Under the hood fulfill uses cheerio. You can specify a replace function that receives the cheerio object representing the response and the responses. You should return a plain string that will finally go to sendMessage or downstream outgoing middleware.&lt;/p&gt;

&lt;h1 id=&#34;using-botmaster-fulfill&#34;&gt;Using botmaster-fulfill&lt;/h1&gt;

&lt;p&gt;Botmaster-fulfill exports two functions. The first is &lt;strong&gt;fulfill&lt;/strong&gt; and implements the fulfill API. The second &lt;strong&gt;outgoing&lt;/strong&gt; produces botmaster outgoing middleware.&lt;/p&gt;

&lt;p&gt;If you look at the quick start example the necessary steps are:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;require the necessary dependencies (the examples gets the outgoing function through destructuring)&lt;/li&gt;
&lt;li&gt;connect our bots to botmaster&lt;/li&gt;
&lt;li&gt;get actions pass as settings object to &lt;strong&gt;outgoing&lt;/strong&gt; function for it to generate our middleware.&lt;/li&gt;
&lt;li&gt;register the resulting middleware to botmaster outgoing middlware.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;additional-middleware-options&#34;&gt;Additional middleware options&lt;/h2&gt;

&lt;p&gt;All of these settings are optional and have reasonable defaults.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;settings.context&lt;/strong&gt; By default &lt;strong&gt;{bot, update}&lt;/strong&gt; is passed as the context object which is made available to actions. If you want any other variables available in the context assign them as values in the &lt;strong&gt;settings.object&lt;/strong&gt;. &lt;strong&gt;bot&lt;/strong&gt; and &lt;strong&gt;update&lt;/strong&gt; will still be passed into the fulfill context and will overwrite any &lt;strong&gt;bot&lt;/strong&gt; or &lt;strong&gt;update&lt;/strong&gt; in your custom context.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;settings.updateToInput&lt;/strong&gt; By default &lt;strong&gt;update.message.text&lt;/strong&gt; is used as the input into response. If this is not acceptable you can define your own function. It will receive an object &lt;strong&gt;{bot, update}&lt;/strong&gt; and expect a string response.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;settings.responseToUpdate&lt;/strong&gt; By default &lt;strong&gt;update.message.text&lt;/strong&gt; is replaced with the response from fulfill. It also returns true for sending an update when the response is not empty (&lt;strong&gt;&amp;ldquo;&lt;/strong&gt;). To define your own setter define a function that accepts &lt;strong&gt;update&lt;/strong&gt; and &lt;strong&gt;response&lt;/strong&gt;, modifies the update in place, and returns true or false whether that update should be sent.&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;using-standalone-without-botmaster&#34;&gt;Using standalone without botmaster&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const {fulfill} = require(&#39;botmaster-fulfill&#39;);
// the input and context would be from your chatbot, but assume they look like this.
// also assume actions above
var input = &amp;quot;&amp;lt;hi /&amp;gt;&amp;quot;;
var context = {};
fulfill(actions, context, input, function(err, response)  {
    // response =  &#39;hello world!&#39;
})
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;setup-hint-drag-and-drop-action-modules&#34;&gt;Setup hint - drag and drop action modules&lt;/h1&gt;

&lt;p&gt;You can drag and drop actions by requiring from an actions folder where you setup your middleware:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const actions = require(&#39;./actions&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In your your actions directory then need to include an index.js:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const fs = require(&amp;quot;fs&amp;quot;);
const path = require(&amp;quot;path&amp;quot;);

fs.readdirSync(__dirname).forEach(function (file) {
    if (file.endsWith(&amp;quot;.js&amp;quot;) &amp;amp;&amp;amp; file !== &amp;quot;index.js&amp;quot;)
        exports[file.substr(0, file.length - 3)] = require(&amp;quot;./&amp;quot; + file);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Each action module should export an object that specifies a controller.&lt;/p&gt;

&lt;h1 id=&#34;debug&#34;&gt;Debug&lt;/h1&gt;

&lt;p&gt;You can enable debug mode by setting &lt;code&gt;DEBUG = botmaster:fulfill:*&lt;/code&gt; in your environment.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>watson conversation</title>
      <link>https://botmasterai.github.io/tutorials/watson-conversation/</link>
      <pubDate>Wed, 30 Nov 2016 10:56:16 +0000</pubDate>
      
      <guid>https://botmasterai.github.io/tutorials/watson-conversation/</guid>
      <description>&lt;p&gt;Lorem Ipsum&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Botmaster or Botkit?</title>
      <link>https://botmasterai.github.io/other-articles/botmaster-or-botkit/</link>
      <pubDate>Sat, 19 Nov 2016 17:07:40 +0000</pubDate>
      
      <guid>https://botmasterai.github.io/other-articles/botmaster-or-botkit/</guid>
      <description>

&lt;h3 id=&#34;tl-dr&#34;&gt;tl;dr&lt;/h3&gt;

&lt;p&gt;Use Botmaster If you want to build platform agnostic conversational bots using a system like Watson Conversation [or your own system] to manage 1 on 1 conversations (On Messenger, Slack, Twitter, Telegram, socket.io or more). e.g. a personal assistant, customer support etc.&lt;/p&gt;

&lt;p&gt;Use Botkit if you want to build platform dependant bots on either Slack or Twilio while managing simple conversations based on regex or also more complex ones using again Watson Conversation or wit etc. You can now also use Microsoft Bot Framework with Botkit. Although I&amp;rsquo;m not too sure why one would want to use  wouldn&amp;rsquo;t just use MS Bot Framework without Botkit.&lt;/p&gt;

&lt;h3 id=&#34;main-article&#34;&gt;Main article&lt;/h3&gt;

&lt;p&gt;Although it might seem at first glance like the two frameworks (and other similar ones out there) were created with the same goal in mind, things are quite far from that. Let&amp;rsquo;s have a look at how one of these frameworks compare, namely Botkit.&lt;/p&gt;

&lt;p&gt;Botkit was initially created to allow developers to easily build bots of all types that would be available on Slack. Although it now allows developers to build bots for twilio IP messaging and Facebook Messenger too. It was first published in December 2015&lt;/p&gt;

&lt;p&gt;Botmaster, on the other hand, is a lightweight framework created after answering the following question: How can I minimise the amount of code a developer has to write in order to create a 1-on-1 conversational chatbot that works on multiple different platforms. It was first published to Github on August 2016.&lt;/p&gt;

&lt;p&gt;Due to the differences in application intents between both frameworks, the design differs in many ways.&lt;/p&gt;

&lt;h2 id=&#34;message-format&#34;&gt;Message format&lt;/h2&gt;

&lt;p&gt;Botkit&amp;rsquo;s messages are only standardized to some extent. Because Botkit it not opinionated, it doesn&amp;rsquo;t make any assumption on what a message attachments or message quick_replies should look like and what they would map to on different platform.&lt;/p&gt;

&lt;p&gt;This means that a Facebook messenger message with an image attachments will look something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  user: &amp;lt;id_of_sender&amp;gt;,
  channel: &amp;lt;id_of_sender&amp;gt;, // also
  timestamp: &amp;lt;unix miliseconds timestamp&amp;gt;,
  seq: &amp;lt;message_sequence_id&amp;gt;,
  mid: &amp;lt;message_id&amp;gt;,
  attachments: [
    {
      type: &#39;image&#39;,
      payload: {
        url: &#39;https://scontent.xx.fbcdn.net/v/.....&#39;
      }
    }
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;While a Twilio IPM message (Twilio IPM only supports text) will look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{ ChannelSid: &amp;lt;some_id&amp;gt;,
  EventType: &#39;onMessageSent&#39;,
  InstanceSid: &amp;lt;some_id&amp;gt;,
  Attributes: &#39;{}&#39;,
  DateCreated: &#39;2016-07-29T18:42:35.686Z&#39;,
  Index: &#39;1&#39;,
  From: &#39;SneakyQuincyEssex&#39;,
  MessageSid: &amp;lt;some_id&amp;gt;,
  Identity: &#39;SneakyQuincyEssex&#39;,
  Body: &#39;yo&#39;,
  AccountSid: &amp;lt;some_id&amp;gt;,
  text: &#39;yo&#39;,
  from: &#39;SneakyQuincyEssex&#39;,
  to: undefined,
  user: &#39;SneakyQuincyEssex&#39;,
  channel: &amp;lt;some_id&amp;gt; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Because of the nature of Twilio and the nature of channels and how they are dealt with, this makes sense. We&amp;rsquo;ll look at what other differences this brings in the next section.&lt;/p&gt;

&lt;p&gt;Standardization is at the heart of Botmaster. The framework was really created for that purpose. In order to do that, the Facebook Messenger message format was chosen and adopted. This means that when your botmaster object receives an &amp;lsquo;update&amp;rsquo; event from anywhere (twitter, telegram as of this writing), you can be sure that it will be of the same format as a similar message that would come from Messenger.
Typically, it would look something like this for a message with an image attachment. Independant of what platform the message comes from:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  raw: &amp;lt;platform_specific_raw_update&amp;gt;,
  sender: {
    id: &amp;lt;id_of_sender&amp;gt;
  },
  recipient: {
    id: &amp;lt;id_of_the_recipent&amp;gt; // will typically be the bot&#39;s id
  },
  timestamp: &amp;lt;unix_miliseconds_timestamp&amp;gt;,
  message: {
    mid: &amp;lt;message_id&amp;gt;,
    seq: &amp;lt;message_sequence_id&amp;gt;,
    attachments: [
      {
        type: &#39;image&#39;,
        payload: {
          url: &#39;https://scontent.xx.fbcdn.net/v/.....&#39;
        }
      }
    ]
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This allows developers to handle these messages in on place only rather than doing it in multiple ones.&lt;/p&gt;

&lt;h2 id=&#34;the-bot-object&#34;&gt;The bot object&lt;/h2&gt;

&lt;p&gt;Confusion may [and most likely will] arise when trying to understand how the bot objects returned with each message differ between both frameworks.&lt;/p&gt;

&lt;p&gt;Botkit has a concept of a controller. Controllers are not platform agnostic according to their definition. So for example a Twilio IPM controller will look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var controller = Botkit.twilioipmbot({
    debug: false,
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This controller could then spawn new Twilio IMP bots. Bots all have a fixed endpoint with a port that can be defined if you need multiple bots of the same type. The bot object is returned with every event and you can then do things like send a message or reply etc with it.&lt;/p&gt;

&lt;p&gt;For messenger, it would look something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const controller = Botkit.facebookbot({
  access_token: messengerCredentials.pageToken,
  verify_token: messengerCredentials.verifyToken,
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;NOTE: Because of the fixed endpoint and the fact that Botkit does not (according to their code as of Aug 18th 2016) verify the integrity of the requests using the Facebook App Secret, I would advise against using it as this means that anyone can make a request to &lt;a href=&#34;https://YOUR_SERVER_URL:PORT_CHOSEN/facebook/receive&#34;&gt;https://YOUR_SERVER_URL:PORT_CHOSEN/facebook/receive&lt;/a&gt; and fake requests from Facebook.&lt;/p&gt;

&lt;p&gt;Of course, you can have multiple controllers in your app. But you will have to manage the various types of incoming messages.&lt;/p&gt;

&lt;p&gt;Botmaster does not have this concept of a controller. In fact, if you are coming from Botkit, you can think of Botmaster as a sort of supercontroller from which you can create a bot of any type as in this example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
// just an example to show what types of settings are expected
const otherMessengerSettings = {
  credentials: {
    verifyToken: messengerCredentials.verifyToken,
    pageToken: messengerCredentials.pageToken, // access_token in Botkit
    fbAppSecret: messengerCredentials.fbAppSecret,
  },
  webhookEndpoint: &#39;/webhook_some_random_string&#39;,
}

const botsSettings = [{ telegram: telegramSettings }, // settings found elsewhere
                      { messenger: messengerSettings }, // settings found elsewhere
                      { messenger: otherMessengerSettings },
                      { twitter: twitterSettings},]; // settings found elsewhere

const botmaster = new Botmaster({settings: botsSettings});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Bot objects are created under the hood and events received by each of them will be relayed to the Botmaster in the standardized Messenger format mentioned in the Message format part. Events are called updates and receiving them looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;botmaster.on(&#39;update&#39;, (bot, update) =&amp;gt; {
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Where the bot object would have been created with any of the 4 settings mentioned. Note the fact that there are 2 messenger settings. Because Botmaster requires an endpoint to be specified in the settings, nothing more than specifying it has to be done there. We recommend people to include some sort of a key in their endpoint as added security for Messenger (on top of the integrity verification from the Facebook app secret) and as basic security for Telegram.&lt;/p&gt;

&lt;h2 id=&#34;working-with-webhooks&#34;&gt;Working with webhooks&lt;/h2&gt;

&lt;p&gt;In order to receive messages, some platforms make the use of webhooks. Which means they will send requests to some endpoints on your server. In order to do that, both frameworks make the use of express() app objects under the hood. Botkit does so for Messenger, Twilio IPM and some of the Slack solutions. Botmaster does do for Messenger and Telegram (for now).&lt;/p&gt;

&lt;p&gt;The standard way to deal with this in Botkit is the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const port = 3000;

controller.setupWebserver(port, function(err, webserver) {
  controller.createWebhookEndpoints(webserver)
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see, this will create an express() webserver and send it onto the &lt;code&gt;createWebhookEndpoints&lt;/code&gt; function. The server will now listen onto the &lt;code&gt;facebook/receive&lt;/code&gt; endpoint on port 3000 if it is a Messenger controller. It will listen onto the &lt;code&gt;&#39;/twilio/receive&#39;&lt;/code&gt; for Twilio IPM and &lt;code&gt;&#39;/slack/receive&#39;&lt;/code&gt; for Slack (if using one of the services that uses webhooks).&lt;/p&gt;

&lt;p&gt;Of course, you might want to use your own express() app webserver to use accross multiple controllers or to serve all sorts of other purposes. You would do this like that in Botkit:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const express = require(&#39;express&#39;);
const app = express();
const bodyParser = require(&#39;body-parser&#39;);

app.use(bodyParser.json());
app.use(bodyParser.urlencoded({ extended: true }));
.
.
.
controller.createWebhookEndpoints(app, bot, () =&amp;gt; {
    console.log(&#39;This bot is online!!!&#39;);
});

app.listen(3000, function() {
  console.log(&#39;Server up&#39;);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In Botmaster, instantiating a botmaster object, will by default just start an express server under the hood for you and make it listen onto port 3000. If you want it to listen onto another port, you can just do something like this when instantiating botmaster:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const port = 3001;
const botmaster = new Botmaster({ settings: botsSettings,
                                 port: port });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The webhook endpoints will be set according to your settings. Go to &lt;a href=&#34;Readme.md#webhooks&#34;&gt;webhooks&lt;/a&gt; in the main readme to read some more about webhooks in Botmaster.&lt;/p&gt;

&lt;p&gt;In order to use your own express app, you would do as follows in Botmaster.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const express = require(&#39;express&#39;);
const app = express();
const bodyParser = require(&#39;body-parser&#39;);

app.use(bodyParser.json());
app.use(bodyParser.urlencoded({ extended: true }));
.
.
.
const botmaster = new Botmaster({settings: botsSettings,
                                 app: app});

app.listen(3000, function() {
  console.log(&#39;Server up&#39;);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By default, Botkit will use different express app webservers for each controller. Botmaster, as mentioned earlier, is a sort of supercontroller. Because of that, it uses the same express webserver accross all channels by default.&lt;/p&gt;

&lt;h2 id=&#34;supported-platforms&#34;&gt;Supported Platforms&lt;/h2&gt;

&lt;p&gt;The following are platforms that are supported out of the box. Both frameworks allow developers to write their own integrations and npm packages might exist for the a platform you are interested in.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;Botmaster&lt;/th&gt;
&lt;th&gt;Botkit&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Facebook Messenger&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Slack&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Twilio IPM&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Twitter DM&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Telegram&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;WebSockets&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;MS Bot framework&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;conversations&#34;&gt;Conversations&lt;/h2&gt;

&lt;p&gt;Botkit allows developers to specify a deterministic conversation flow within the code to simplify such flows. This is definitely handy and something that can help when creating Slack and Twilio bots&lt;/p&gt;

&lt;p&gt;Because Botmaster was initialy built mainly as a standardization agnostic layer that assumes your messages will be sent to some sort of AI service like Watson Conversation and others, this hasn&amp;rsquo;t been builtin to the first version. This is however something that will come soon (in a different form from the ones in Botkit). Depending on requests however, it could come sooner or later.&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;I hope this all made some sort of sense to you and that you are now able to make a sensible decision with respect to which framework to use.&lt;/p&gt;

&lt;p&gt;I realize there are other frameworks out there too that I haven&amp;rsquo;t mentioned. If anyone would like to look into them and tell me what the differences are, I&amp;rsquo;d be happy to add them to another file.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Botmaster Basics</title>
      <link>https://botmasterai.github.io/working-with-botmaster/botmaster-basics/</link>
      <pubDate>Fri, 04 Nov 2016 01:31:15 +0000</pubDate>
      
      <guid>https://botmasterai.github.io/working-with-botmaster/botmaster-basics/</guid>
      <description>

&lt;h3 id=&#34;bot-object&#34;&gt;Bot object&lt;/h3&gt;

&lt;p&gt;Hopefully, by now you&amp;rsquo;ve gathered your credentials for at least one platform and got some basic bot running. We remember from the &lt;a href=&#34;https://botmasterai.github.io/getting-started/quickstart&#34;&gt;quickstart&lt;/a&gt; and the various Setup guides in &lt;a href=&#34;https://botmasterai.github.io/getting-started&#34;&gt;getting-started&lt;/a&gt; that we can start a botmaster project like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const Botmaster = require(&#39;botmaster&#39;);

const botmaster = new Botmaster();
.
. // full settings objects omitted for brevity
.
const messengerBot = new Botmaster.botTypes.MessengerBot(messengerSettings);
const slackBot = new Botmaster.botTypes.SlackBot(slackSettings);
const socketioBot = new Botmaster.botTypes.SocketioBot(socketioSettings));
const twitterBot = new Botmaster.botTypes.TwitterBot(twitterSettings);
const telegramBot = new Botmaster.botTypes.TelegramBot(telegramSettings);

botmaster.addBot(messengerBot);
botmaster.addBot(slackBot);
botmaster.addBot(twitterBot);
botmaster.addBot(socketioBot);
botmaster.addBot(telegramBot);
.
.
.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As it turns out, bot objects are really the ones running the show in the Botmaster framework. Your &lt;code&gt;botmaster&lt;/code&gt; object is simply a central point of control for you to manage all of your bots. Botmaster assumes that most of your bots will have a central bit of code that you don&amp;rsquo;t want to have to replicate for every platform/bot instance. Which should make sense.&lt;/p&gt;

&lt;p&gt;Although the point of botmaster is for developers to do something like this after declaring the botmaster instance:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;botmaster.on(&#39;update&#39;, (bot, update) =&amp;gt; {
  // do stuff with your bot and update here
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;One could (but shouldn&amp;rsquo;t) just as well do:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;messengerBot.on(&#39;update&#39;, (update) =&amp;gt; {
  // do stuff with your messenger bot here
});

// this applies to all the bot objects that would have been declared separately.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I say one shouldn&amp;rsquo;t do that here because the only reason why this callback would work in this situation is because we&amp;rsquo;ve already called &lt;code&gt;botmaster.addBot(messengerBot)&lt;/code&gt;. If we hadn&amp;rsquo;t done that, we would have to mount the &lt;code&gt;messengerBot&lt;/code&gt; object onto an express app ourselves. See &lt;a href=&#34;https://botmasterai.github.io/working-with-botmaster/writing-your-own-bot-class&#34;&gt;writing your own bot class&lt;/a&gt; to read more on this.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;update&lt;/code&gt; object in the event callback is the same as the botmaster &lt;code&gt;update&lt;/code&gt; one you would get in the botmaster update callback. Of course the &lt;code&gt;messenger.on(...)&lt;/code&gt; piece of code would only apply to your &lt;code&gt;messengerBot&lt;/code&gt; instance and not the others.&lt;/p&gt;

&lt;p&gt;As seen, bot instances can be accessed directly within an &lt;code&gt;update&lt;/code&gt; event. Because you might want to act differently on bots of a certain type or log information differently based on type, every bot comes with a &lt;code&gt;bot.type&lt;/code&gt; parameter that is one of: &lt;code&gt;messenger&lt;/code&gt;, &lt;code&gt;slack&lt;/code&gt;, &lt;code&gt;twitter&lt;/code&gt;, &lt;code&gt;socketio&lt;/code&gt;, &lt;code&gt;telegram&lt;/code&gt; or whatever third-party bot class you might have installed or created.&lt;/p&gt;

&lt;p&gt;It is important to note here, that you can have multiple bot objects for a certain type. I&amp;rsquo;m sure you can find reasons for why you would want to do this. This is important to mention, as you might have, say, 2 bots of type &lt;code&gt;messenger&lt;/code&gt; dealt with via Botmaster. You might want to do platform specific code by doing the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;botmaster.on(&#39;update&#39;, (bot, update) =&amp;gt; {
  if (bot.type === &#39;messenger&#39; {
    // do messenger specific stuff
    return;
  })
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then you might want to do bot object specific code. You would do this as such:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;botmaster.on(&#39;update&#39;, (bot, update) =&amp;gt; {
  if (bot.type === &#39;messenger&#39; {
    // do messenger specific stuff
    if (bot.id === &#39;YOUR_BOT_ID&#39;) {// this will be the user id of bot for messenger
      // do bot object specific stuff
      return;
    }
  })
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or if you declared your bots and botmaster as in the beginning of this section, you might have done the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const Botmaster = require(&#39;botmaster&#39;);
const botmaster = new Botmaster();
// These are some of the bot classes that come with Botmaster
const Messengerbot = Botmaster.botTypes.MessengerBot;
const SlackBot = Botmaster.botTypes.SlackBot;
const TwitterBot = Botmaster.botTypes.TwitterBot;
.
. // full settings objects omitted for brevity
.
const messengerBot1 = new MessengerBot(messengerSettings1);
const messengerBot2 = new MessengerBot(messengerSettings2);
const slackBot = new SlackBot(slackSettings);
const twitterBot = new TwitterBot(twitterSettings);

botmaster.addBot(messengerBot);
botmaster.addBot(slackBot);
botmaster.addBot(twitterBot);

botmaster.on(&#39;update&#39;, (bot, update) =&amp;gt; {
  if (bot.type === &#39;messenger&#39; {
    // do messenger bot specific stuff


    if (bot === messengerBot1) { // without using ids
      // do messengerBot1 specific stuff
    }
    return;
  })
})
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;notices warning&#34; &gt;&lt;p&gt;Botmaster does not assure you that the &lt;code&gt;id&lt;/code&gt; parameter of the &lt;code&gt;bot&lt;/code&gt; object will exist upon instantiation. the &lt;code&gt;id&lt;/code&gt; is only assured to be there once an update has been received by the bot. This is because some ids aren&amp;rsquo;t known until botmaster knows &amp;lsquo;who&amp;rsquo; the message was sent to (i.e. what id your bot should have).&lt;/p&gt;
&lt;/div&gt;


&lt;p&gt;I&amp;rsquo;ll note quickly that each bot object created comes from one of the various bot classes as seen above. They act in the same way on the surface (because of heavy standardization), but have a few idiosynchrasies here and there.&lt;/p&gt;

&lt;p&gt;Also useful to note is that you can access all the bots added to botmaster by doing &lt;code&gt;botmaster.bots&lt;/code&gt;. you can also use &lt;code&gt;botmastet.getBot&lt;/code&gt; or &lt;code&gt;botmaster.getBots&lt;/code&gt; to get a specific bot (using type or id);&lt;/p&gt;

&lt;p&gt;It is important to take note of the &lt;code&gt;addBot&lt;/code&gt; syntax as you can create your own Bot class that extends the &lt;code&gt;Botmaster.botTypes.BaseBot&lt;/code&gt; class. For instance, you might want to create your own class that supports your pre-existing messaging standards. Have a look at the &lt;a href=&#34;working-with-botmaster/writing-a-botmaster-supported-bot-class-readme.md&#34;&gt;working with a botmaster supported bot class &lt;/a&gt; documentation to learn how to do this.&lt;/p&gt;

&lt;h3 id=&#34;settings&#34;&gt;Settings&lt;/h3&gt;

&lt;p&gt;Botmaster can be started with a so-called &lt;code&gt;botmasterSettings&lt;/code&gt; object. It has the following parameters:
The &lt;code&gt;botmasterSettings&lt;/code&gt; object has the following parameters:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Parameter&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;port&lt;/td&gt;
&lt;td&gt;(&lt;strong&gt;optional&lt;/strong&gt;) The port to use for your webhooks (see &lt;a href=&#34;#webhooks&#34;&gt;webhooks&lt;/a&gt; to understand more about webhooks). This will only be used if the &lt;code&gt;app&lt;/code&gt; parameter is not provided. Otherwise, it will be ignored&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;app&lt;/td&gt;
&lt;td&gt;(&lt;strong&gt;optional&lt;/strong&gt;) An &lt;code&gt;express.js&lt;/code&gt; app object to mount the &lt;code&gt;webhookEnpoints&lt;/code&gt; onto. If you choose to do this, it is assumed that you will be starting your own express server and this won&amp;rsquo;t be done by Botmaster. Unless you also specify a &lt;code&gt;server&lt;/code&gt; parameter, &lt;code&gt;botmaster.server&lt;/code&gt; will be &lt;code&gt;undefined&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;div class=&#34;notices warning&#34; &gt;&lt;p&gt;&lt;code&gt;botsSettings&lt;/code&gt; and &lt;code&gt;server&lt;/code&gt; parameters have been deprecated in version 2.2.3. Please use &lt;code&gt;addBot&lt;/code&gt; instead of botsSettings and set the socketio server in your socketSettings object.&lt;/p&gt;
&lt;/div&gt;


&lt;p&gt;Using botsSettings would look something like this if you want to set the port:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const Botmaster = require(&#39;botmaster&#39;);

const botmasterSettings = {
  // by default botmaster will start an express server that listens on port 3000
  // you can pass in a port argument here to change this default setting:
  port: 3001
}

const botmaster = new Botmaster(botmasterSettings);

.
. // rest of code adding bots to botmaster etc
.

&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;notices info&#34; &gt;&lt;p&gt;Please note, unless you are passing in an &lt;code&gt;app&lt;/code&gt; object to the settings, it is assumed that you don&amp;rsquo;t want to deal with anything relating to an http server. That is, botmaster will create an express server under the hood and expose both: &lt;code&gt;botmaster.app&lt;/code&gt; and &lt;code&gt;botmaster.server&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;


&lt;h4 id=&#34;setting-botmastersettings-to-use-botmaster-with-your-own-express-app&#34;&gt;Setting &lt;code&gt;botmasterSettings&lt;/code&gt; to use Botmaster with your own express() app&lt;/h4&gt;

&lt;p&gt;Here&amp;rsquo;s an example on how to do so if you are setting your credentials in your environment variables:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const express = require(&#39;express&#39;);
const Botmaster = require(&#39;botmaster&#39;);

const app = express();
const port = 3000;
const botmasterSettings = { app: app };
const botmaster = new Botmaster(botmasterSettings);

// settings and adding those to botmaster
const telegramSettings = {
  credentials: {
    authToken: process.env.TELEGRAM_TOKEN,
  },
  webhookEndpoint: &#39;/webhook1234/&#39;,
};

const messengerSettings = {
  credentials: {
    verifyToken: process.env.MESSENGER_VERIFY_TOKEN,
    pageToken: process.env.MESSENGER_PAGE_TOKEN,
    fbAppSecret: process.env.FACEBOOK_APP_SECRET,
  },
  webhookEndpoint: &#39;/webhook1234/&#39;,
};

const messengerBot = new Botmaster.botTypes.MessengerBot(messengerSettings);
const telegramBot = new Botmaster.botTypes.TelegramBot(telegramSettings);

botmaster.addBot(messengerBot);
botmaster.addBot(telegramBot);
////////

botmaster.on(&#39;update&#39;, (bot, update) =&amp;gt; {
  bot.sendMessage({
    recipient: {
      id: update.sender.id,
    },
    message: {
      text: &#39;Well right back at you!&#39;,
    },
  });
});

// start server on the specified port and binding host
app.listen(port, &#39;0.0.0.0&#39;, () =&amp;gt; {
  // print a message when the server starts listening
  console.log(`Running App on port: ${port}`);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;events&#34;&gt;Events&lt;/h3&gt;

&lt;p&gt;Botmaster is built on top of the EventEmitter node.js class. Which means it can emit events and most importantly for us here, it can listen onto them. By doing any of the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;botmaster.on(&#39;server running&#39;, (message) =&amp;gt; {
  console.log(message);
});

botmaster.on(&#39;update&#39;, (bot, update) =&amp;gt; {
  console.log(bot.type);
  console.log(update);
});

botmaster.on(&#39;error&#39;, (bot, err) =&amp;gt; {
  console.log(bot.type);
  console.log(err.stack);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These are the only four listeners that you can listen onto in botmaster. Let&amp;rsquo;s go though them briefly:&lt;/p&gt;

&lt;h4 id=&#34;server-running&#34;&gt;server running&lt;/h4&gt;

&lt;p&gt;This event will be emitted only if you are not managing your own server (i.e. you started botmaster without setting the &lt;code&gt;app&lt;/code&gt; parameter). It is just here to notify you that the server has been started. You don&amp;rsquo;t necessarily need to use it. But you might want to do things at this point.&lt;/p&gt;

&lt;h4 id=&#34;update&#34;&gt;update&lt;/h4&gt;

&lt;p&gt;This is really where all the magic happens. Whenever a message (update in Botmaster semantic) is sent into your application. Botmaster will parse it and format it into its [FB Messenger] standard. Along with it, you will get a &lt;code&gt;bot&lt;/code&gt; object which is the underlying object into which the message was sent. Note that the updates are standardized as well as the methods to use from the bot object (i.e. sending a message). Read further down to see how those two objects work.&lt;/p&gt;

&lt;h4 id=&#34;error&#34;&gt;error&lt;/h4&gt;

&lt;p&gt;This event is thrown whenever an error internal to Botmaster occurs. I.e. if for some reason a misconfigured message was sent in. Or if some other kind of error occurred directly within Botmaster. It is good to listen onto this event and keep track of potential errors. Also, if you code an error within &lt;code&gt;botmaster.on&lt;/code&gt;, and don&amp;rsquo;t catch it, it will be caught by Botmaster and emitted in to &lt;code&gt;error&lt;/code&gt;. So like this you have full control of what is going on and can log everything straight from there.&lt;/p&gt;

&lt;h2 id=&#34;message-update-format&#34;&gt;Message/Update format&lt;/h2&gt;

&lt;p&gt;Standardization is at the heart of Botmaster. The framework was really created for that purpose. This means that messages coming from any platform have to have the same format.&lt;/p&gt;

&lt;p&gt;In order to do that, the &lt;strong&gt;Facebook Messenger message format&lt;/strong&gt; was chosen and adopted. This means that when your botmaster object receives an &amp;lsquo;update&amp;rsquo; event from anywhere, you can be sure that it will be of the same format as a similar message that would come from Facebook Messenger.&lt;/p&gt;

&lt;h3 id=&#34;incoming-update&#34;&gt;Incoming update&lt;/h3&gt;

&lt;p&gt;Typically, it would look something like this for a message with an image attachment. Independent of what platform the message comes from:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;{
  raw: &amp;lt;platform_specific_raw_update&amp;gt;,
  sender: {
    id: &amp;lt;id_of_sender&amp;gt;
  },
  recipient: {
    id: &amp;lt;id_of_the_recipent&amp;gt; // will typically be the bot&#39;s id
  },
  timestamp: &amp;lt;unix_miliseconds_timestamp&amp;gt;,
  message: {
    mid: &amp;lt;message_id&amp;gt;,
    seq: &amp;lt;message_sequence_id&amp;gt;,
    attachments: [
      {
        type: &#39;image&#39;,
        payload: {
          url: &#39;https://scontent.xx.fbcdn.net/v/.....&#39;
        }
      }
    ]
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This allows developers to handle these messages in one place only rather than doing it in multiple places. For more info on the various incoming messages formats, read the messenger bot doc on webhooks at: &lt;a href=&#34;https://developers.facebook.com/docs/messenger-platform/webhook-reference/message-received&#34;&gt;https://developers.facebook.com/docs/messenger-platform/webhook-reference/message-received&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Currently, you will only get updates for &lt;code&gt;Messages&lt;/code&gt; (and not delivery, echo notification etc) for all platforms. On Messenger, it is assumed that you don&amp;rsquo;t want to get updates for delivery, read and echo. This can&amp;rsquo;t be turned on at the moment, but will be in later versions as it might be a requirement.&lt;/p&gt;

&lt;h4 id=&#34;note-on-attachment-types-and-conversions&#34;&gt;Note on attachment types and conversions&lt;/h4&gt;

&lt;p&gt;Attachment type conversion on incoming updates works as such for &lt;strong&gt;Twitter&lt;/strong&gt;:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Twitter Type&lt;/th&gt;
&lt;th&gt;Botmaster conversion&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;photo&lt;/td&gt;
&lt;td&gt;image&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;video&lt;/td&gt;
&lt;td&gt;video&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;gif&lt;/td&gt;
&lt;td&gt;video&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;!!!Yes &lt;code&gt;gif&lt;/code&gt; becomes a &lt;code&gt;video&lt;/code&gt;. because Twitter doesn&amp;rsquo;t actually use gifs the way you would expect it to. It simply loops over a short &lt;code&gt;.mp4&lt;/code&gt; video.&lt;/p&gt;

&lt;p&gt;Also, here&amp;rsquo;s an important caveat for Twitter bot developers who are receiving attachments. Image links that come in from the Twitter API will be private and not public, which makes using them quite tricky. You might need to make authenticated requests to do so. The twitterBot objects you will receive in the update will have a &lt;code&gt;bot.twit&lt;/code&gt; object. Documentation for how to use this is available &lt;a href=&#34;https://github.com/ttezel/twit&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Receiving and sending attachments [the Botmaster way] is not yet supported on &lt;strong&gt;Slack&lt;/strong&gt; as of version 2.2.1. However, Slack supports url unfurling (meaning if you send images and other types of media this will be shown in the messages and users won&amp;rsquo;t just see a url). Also, because of how Botmaster is built (don&amp;rsquo;t throw any of the original information from the message away) you can find all the necessary information in the &lt;code&gt;update.raw&lt;/code&gt; object of the update.&lt;/p&gt;

&lt;p&gt;Attachment type conversion works as such for &lt;strong&gt;Telegram&lt;/strong&gt;:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Telegram Type&lt;/th&gt;
&lt;th&gt;Botmaster conversion&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;audio&lt;/td&gt;
&lt;td&gt;audio&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;voice&lt;/td&gt;
&lt;td&gt;audio&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;photo&lt;/td&gt;
&lt;td&gt;image&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;video&lt;/td&gt;
&lt;td&gt;video&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;location&lt;/td&gt;
&lt;td&gt;location&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;venue&lt;/td&gt;
&lt;td&gt;location&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;code&gt;contact&lt;/code&gt; attachment types aren&amp;rsquo;t supported in Messenger. So in order to deal with them in Botmaster, you will have to look into your &lt;code&gt;update.raw&lt;/code&gt; object which is the standard Telegram update. You will find your contact object in &lt;code&gt;update.raw.contact&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Also, concerning &lt;code&gt;location&lt;/code&gt; and &lt;code&gt;venue&lt;/code&gt; attachments. The url received in Botmaster for Telegram is a google maps one with the coordinates as query parameters. It looks something like this: &lt;code&gt;https://maps.google.com/?q=&amp;lt;lat&amp;gt;,&amp;lt;long&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;A few of you will want to use attachments with your &lt;code&gt;socket.io&lt;/code&gt; bots. Because the Botmaster message standard is the Facebook Messenger one, everything is URL based. Which means it is left to the developer to store both incoming and outgoing attachments. A tutorial on how to deal with this will be up soon in the &lt;a href=&#34;https://botmasterai.github.io/tutorials&#34;&gt;Tutorials&lt;/a&gt; section.&lt;/p&gt;

&lt;h3 id=&#34;outgoing-messages&#34;&gt;Outgoing messages&lt;/h3&gt;

&lt;p&gt;Again, outgoing messages are expected to be formatted like messages the Messenger platform would expect. They will typically look something like this for a text message:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const message = {
  recipient: {
    id: update.sender.id,
  },
  message: {
    text: &#39;Some arbitrary text of yours&#39;
  },
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and you would use this as such in code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;botmaster.on(&#39;update&#39;, (bot, update) =&amp;gt; {
  const message = {
    recipient: {
      id: update.sender.id,
    },
    message: {
      text: &#39;Some arbitrary text of yours&#39;
    },
  };
  bot.sendMessage(message);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see, the &lt;code&gt;sendMessage&lt;/code&gt; method used is used directly from the bot object and not using the botmaster one.&lt;/p&gt;

&lt;p&gt;Because you might not always want to code in a complex json object just to send in a simple text message or photo attachment, Botmaster comes with a few helper methods that can be used to send messages with less code:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;bot.sendMessageTo&lt;/code&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Argument&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;message&lt;/td&gt;
&lt;td&gt;an object without the recipient part. In the previous example, it would be &lt;code&gt;message.message&lt;/code&gt;.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;recipientId&lt;/td&gt;
&lt;td&gt;a string representing the id of the user to whom you want to send the message.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;code&gt;bot.sendTextMessageTo&lt;/code&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Argument&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;text&lt;/td&gt;
&lt;td&gt;just a string with the text you want to send to your user&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;recipientId&lt;/td&gt;
&lt;td&gt;a string representing the id of the user to whom you want to send the message.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Typically used like so to send a text message to the user who just spoke to the bot:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;botmaster.on(&#39;update&#39;, (bot, update) =&amp;gt; {
  bot.sendTextMessageTo(&#39;something super important&#39;, update.sender.id);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;bot.reply&lt;/code&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Argument&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;update&lt;/td&gt;
&lt;td&gt;an update object with a valid &lt;code&gt;update.sender.id&lt;/code&gt;.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;text&lt;/td&gt;
&lt;td&gt;just a string with the text you want to send to your user&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;This is is typically used like so:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;botmaster.on(&#39;update&#39;, (bot, update) =&amp;gt; {
  bot.reply(update, &#39;something super important!&#39;);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;attachments&#34;&gt;Attachments&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;bot.sendAttachmentTo&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll note here really quickly that Messenger only takes in urls for file attachment (image, video, audio, file). Most other platforms don&amp;rsquo;t support sending attachments in this way. So we fall back to sending the url in text which really results in a very similar output. Same goes for Twitter that doesn&amp;rsquo;t support attachments at all.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Argument&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;attachment&lt;/td&gt;
&lt;td&gt;a valid Messenger style attachment. See &lt;a href=&#34;https://developers.facebook.com/docs/messenger-platform/send-api-reference&#34;&gt;here&lt;/a&gt; for more on that.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;recipientId&lt;/td&gt;
&lt;td&gt;a string representing the id of the user to whom you want to send the message.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;This is the general attachment sending method that will always work for Messenger but not necessarily for other platforms as Facebook Messenger supports all sorts of attachments that other platforms don&amp;rsquo;t necessarily support. So beware when using it. To assure your attachment will be sent to all platforms, use &lt;code&gt;bot.sendAttachmentFromURLTo&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This is typically used as such for sending an image url.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;botmaster.on(&#39;update&#39;, (bot, update) =&amp;gt; {
  const attachment = {
    type: &#39;image&#39;
    payload: {
      url: &amp;quot;some image url you&#39;ve got&amp;quot;,
    },
  };
  bot.sendAttachment(attachment, update.sender.id);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;bot.sendAttachmentFromURLTo&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Just easier to use this to send standard url attachments. And URL attachments if used properly should work on all out-of-the-box platforms:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Argument&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;type&lt;/td&gt;
&lt;td&gt;string representing the type of attachment (audio, video, image or file)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;url&lt;/td&gt;
&lt;td&gt;the url to your file&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;recipientId&lt;/td&gt;
&lt;td&gt;a string representing the id of the user to whom you want to send the message.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;This is typically used as such for sending an image url.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;botmaster.on(&#39;update&#39;, (bot, update) =&amp;gt; {
  bot.sendAttachment(&#39;image&#39;, &amp;quot;some image url you&#39;ve got&amp;quot;, update.sender.id);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;status&#34;&gt;Status&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;bot.sendIsTypingMessageTo&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;To indicate that something is happening on your bots end, you can show your users that the bot is &amp;lsquo;working&amp;rsquo; or &amp;lsquo;typing&amp;rsquo; something. to do so, simply invoke sendIsTypingMessageTo.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Argument&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;recipientId&lt;/td&gt;
&lt;td&gt;a string representing the id of the user to whom you want to send the message.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;It is used as such:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;botmaster.on(&#39;update&#39;, (bot, update) =&amp;gt; {
  bot.sendIsTypingMessageTo(update.sender.id);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It will only send a request to the platforms that support it. If unsupported, nothing will happen.&lt;/p&gt;

&lt;h4 id=&#34;buttons&#34;&gt;Buttons&lt;/h4&gt;

&lt;p&gt;Buttons will almost surely be part of your bot. Botmaster provides a method that will send what is assumed to be a decent way to display buttons throughout all platforms.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;bot.sendDefaultButtonMessageTo&lt;/code&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Argument&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;buttonTitles&lt;/td&gt;
&lt;td&gt;array of button titles (no longer than 10 in size).&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;recipientId&lt;/td&gt;
&lt;td&gt;a string representing the id of the user to whom you want to send the message.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;textOrAttachment&lt;/td&gt;
&lt;td&gt;(&lt;strong&gt;optional&lt;/strong&gt;) a string or an attachment object similar to the ones required in &lt;code&gt;bot.sendAttachmentTo&lt;/code&gt;. This is meant to provide context to the buttons. I.e. why are there buttons here. A piece of text or an attachment could detail that. If not provided,  text will be added that reads: &amp;lsquo;Please select one of:&amp;lsquo;.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;The function defaults to sending &lt;code&gt;quick_replies&lt;/code&gt; in Messenger, setting &lt;code&gt;Keyboard buttons&lt;/code&gt; in Telegram, buttons in Slack and simply prints button titles one on each line in Twitter as it doesn&amp;rsquo;t support buttons. The user is expecting to type in their choice in Twitter. In the socketio implementation, the front-end/app developer is expected to write the code that would display the buttons on their front-end.&lt;/p&gt;

&lt;h4 id=&#34;cascade&#34;&gt;Cascade&lt;/h4&gt;

&lt;p&gt;In order to send a cascade of messages (i.e. multiple messages one after another), you might want to have a look at both of these methods:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;bot.sendCascadeTo&lt;/code&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Argument&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;messageArray&lt;/td&gt;
&lt;td&gt;Array of messages in a format as such: [{text: &amp;lsquo;something&amp;rsquo;}, {message: someMessengerValidMessage}] read below to see valid keys.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;recipientId&lt;/td&gt;
&lt;td&gt;a string representing the id of the user to whom you want to send the message.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;As you might have guessed, Botmaster assures you that the objects in the messageArray will be sentin order. Furthermore, the objects of the messageArray must be of a certain form:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;{
  raw: SOME_VALID_RAW_MESSAGE, // the same object as one you would send with sendRaw()
  message: SOME_VALID_MESSENGER_MESSAGE, // the same object as one you would send with sendMessage() (i.e. the recipientId won&#39;t be taken into account!)
  buttons: SOME_ARRAY_OF_BUTTON_TITLES, // same as what you would do with: sendDefaultButtonMessageTo. If you will be sending attachments/text alongside it, add them in the following fields. If both are present, the attachment will be used.
  attachment: SOME_ATTACHMENT, // same object format as in: sendAttachmentTo()
  text: &#39;some text&#39;, // same as when using sendTextMessageTo()
  isTyping: SOME_TRUTHY_VALUE, // will call sendIsTypingMessageTo() on the recipientId used in sendCascade.
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;bot.sendTextCascadeTo&lt;/code&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Argument&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;textMessageArray&lt;/td&gt;
&lt;td&gt;Array of strings that you want to send to the user in sequences.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;recipientId&lt;/td&gt;
&lt;td&gt;a string representing the id of the user to whom you want to send the message.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;This method is really just a helper for calling &lt;code&gt;bot.sendCascadeTo&lt;/code&gt;. It just allows developers to use the method with an array of texts rather than an array of objects.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Installation</title>
      <link>https://botmasterai.github.io/getting-started/installation/</link>
      <pubDate>Mon, 31 Oct 2016 18:46:54 +0000</pubDate>
      
      <guid>https://botmasterai.github.io/getting-started/installation/</guid>
      <description>&lt;p&gt;Make sure you have &lt;a href=&#34;https://nodejs.org/en/&#34;&gt;Node.js&lt;/a&gt; and npm installed on your machine. If you don&amp;rsquo;t, I recommend using nvm to manage your node versions. Find out more about it &lt;a href=&#34;https://github.com/creationix/nvm/blob/master/README.markdown&#34;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Once you have node, create a new project directory and go into it:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mkdir my_botmaster_project &amp;amp;&amp;amp; cd my_botmaster_project
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Make sure you initialize a node project in the new directory and going through the prompt by doing:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;npm init
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, install the botmaster npm package.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;npm install --save botmaster
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That should do!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Writing your Own Bot Class</title>
      <link>https://botmasterai.github.io/working-with-botmaster/writing-your-own-bot-class/</link>
      <pubDate>Thu, 17 Nov 2016 18:16:51 +0000</pubDate>
      
      <guid>https://botmasterai.github.io/working-with-botmaster/writing-your-own-bot-class/</guid>
      <description>

&lt;h2 id=&#34;bot-classes&#34;&gt;Bot classes&lt;/h2&gt;

&lt;p&gt;The following document assumes that you have read the main documentation in &amp;ldquo;getting started&amp;rdquo; and in &amp;ldquo;botmaster basics&amp;rdquo;. A general understand of how Botmaster and more generally how chatbots work is also assumed.&lt;/p&gt;

&lt;p&gt;Because of that, we will pick up right from there and start looking into the bot classes Botmaster comes bundled with.&lt;/p&gt;

&lt;p&gt;Botmaster makes five usable bot classes available to developers out of the box. &lt;code&gt;MessengerBot&lt;/code&gt;, &lt;code&gt;SlackBot&lt;/code&gt;, &lt;code&gt;SocketioBot&lt;/code&gt;, &lt;code&gt;TelegramBot&lt;/code&gt; and &lt;code&gt;TwitterBot&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;For example, you can instantiate a new &lt;code&gt;MessengerBot&lt;/code&gt; object as such:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const Botmaster = require(&#39;botmaster&#39;);
const MessengerBot = Botmaster.botTypes.MessengerBot;

const messengerSettings = {
  credentials: {
    verifyToken: &#39;YOUR verifyToken&#39;,
    pageToken: &#39;YOUR pageToken&#39;,
    fbAppSecret: &#39;YOUR fbAppSecret&#39;
  },
  webhookEndpoint: &#39;/webhook1234&#39;,
};

const messengerBot = new MessengerBot(messengerSettings);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In order to get updates from Messenger, you would then be expected to mount your bot&amp;rsquo;s express mini-app &lt;code&gt;messengerBot.app&lt;/code&gt; onto your own express &lt;code&gt;app&lt;/code&gt; by doing something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const app = require(&#39;express&#39;)();
app.use(&#39;/&#39;, messengerBot.app);
app.listen(3001, function() {});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or even better:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;messengerBot.app.listen(3001, function() {});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will mount your bot onto: &lt;code&gt;https://Your_Domain_Name:3001/webhook1234&lt;/code&gt;. Note how the bot type &lt;strong&gt;is not&lt;/strong&gt; part of the URL here.&lt;/p&gt;

&lt;h2 id=&#34;making-botmaster-objects-and-bot-objects-work-together&#34;&gt;Making Botmaster objects and bot objects work together&lt;/h2&gt;

&lt;p&gt;Doing this is really trivial and as it turns out, you do this every time you use the &lt;code&gt;addBot&lt;/code&gt; method.&lt;/p&gt;

&lt;p&gt;We recall from the various guides that to create a botmaster object the following is needed:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const Botmaster = require(&#39;botmaster&#39;);
const botmaster = new Botmaster();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As usual, we create a botmaster object. This one supports Twitter and Telegram, but not Messenger. We create it as such:&lt;/p&gt;

&lt;p&gt;In this example the &lt;code&gt;botmaster&lt;/code&gt; object will start a new &lt;code&gt;express()&lt;/code&gt; &lt;code&gt;app&lt;/code&gt; server running locally on port &lt;code&gt;3000&lt;/code&gt; as expected by default (see &lt;a href=&#34;https://botmasterai.github.io/working-with-botmaster/botmaster-basics/#using-botmaster-with-your-own-express-app&#34;&gt;here&lt;/a&gt; to see how to change that).&lt;/p&gt;

&lt;p&gt;As usual, we add the messenegrBot as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;botmaster.addBot(messengerBot);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will mount your bot onto: &lt;code&gt;https://Your_Domain_Name:3000/messenger/webhook1234&lt;/code&gt;. Note how the bot type &lt;strong&gt;is&lt;/strong&gt; part of the endpoint here. This is because the Botmaster class assumes that you want your endpoint to be mounted onto its botType.&lt;/p&gt;

&lt;p&gt;You will then get updates from the botmaster object as if you had instantiated it with the messenger settings too if your endpoint is setup properly.&lt;/p&gt;

&lt;div class=&#34;notices info&#34; &gt;&lt;p&gt;Please note, if you followed these steps and put all this code in one file. You will actually have two express servers running along side each other. One on port 3001 and one on port 3000. Both endpoints mentioned above would work. This is definitely not what you want to do in production. Pick one of the methods and stick to it in production.&lt;/p&gt;
&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;The main takeaway from all this is that any bot class that follows a  certain set of rules will be able to be added to a botmaster object.&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;creating-your-own-bot-classes&#34;&gt;Creating your own bot classes&lt;/h2&gt;

&lt;p&gt;Before defining the rules that have to be respected in order to write a Botmaster compatible bot class let&amp;rsquo;s look at the constructor of one of the existing one, &lt;code&gt;TelegramBot&lt;/code&gt;:&lt;/p&gt;

&lt;h3 id=&#34;constructor-settings&#34;&gt;&lt;code&gt;#constructor(settings)&lt;/code&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;class TelegramBot extends BaseBot {

  constructor(settings) {
    super(settings);
    this.type = &#39;telegram&#39;;
    this.requiresWebhook = true;
    this.requiredCredentials = [&#39;authToken&#39;];

    this.__applySettings(settings);
    .
    .
    .
    this.__createMountPoints();
  }

 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s look into this line by line. The first line reads &lt;code&gt;super(settings)&lt;/code&gt;. Which of course just means it calls the constructor of &lt;code&gt;TelegramBot&lt;/code&gt;&amp;rsquo;s superclass, namely, &lt;code&gt;BaseBot&lt;/code&gt;. &lt;code&gt;BaseBot&lt;/code&gt;&amp;rsquo;s constructor doesn&amp;rsquo;t actually do anything fancy a part from calling its own superclass&amp;rsquo;s constructor and setting a few default values [as pointers for you, the developer]. BaseBot calls its own superclass&amp;rsquo;s constructor as it inherits from node.js&amp;rsquo;s &lt;code&gt;EventEmitter&lt;/code&gt; which will allow your bot&amp;rsquo;s classes to listen to events as well as emit them.&lt;/p&gt;

&lt;p&gt;The following three lines setup some important values.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;this.type&lt;/code&gt;: the type of bot that is being instantiated. It&amp;rsquo;s important to specify that as developers might want to condition some code on the type of bot you are writing.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;this.requiresWebhook&lt;/code&gt;: whether the bot requires webhooks. If the platform you are coding for requires webhooks, you will be expected to set a &lt;code&gt;this.app&lt;/code&gt; variable at some point in the setup. We&amp;rsquo;ll look into this when we have a look at what the &lt;code&gt;this.__createMountPoints();&lt;/code&gt; does.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;this.requiredCredentials&lt;/code&gt;: sets up an array of credentials that are expected to be defined for the platform you are coding your class for. Telegram only takes in 1, so we just have an array with the value &lt;code&gt;&#39;authToken&#39;&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;applysettings-settings&#34;&gt;&lt;code&gt;#__applySettings(settings)&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;The next line calls the &lt;code&gt;this.__applySettings(settings)&lt;/code&gt; function. This function is implemented in BaseBot and will just make sure that the settings passed on to the bot constructor are valid with respect to the parameters you defined. You should always call this function directly after setting the three [or more or less depending on your bot] parameters specific to the platform you are coding for. If valid, the settings will then be applied to the bot object. e.g. &lt;code&gt;this.webhookEndpoint&lt;/code&gt; will be set to &lt;code&gt;settings.webhookEndpoint&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;createmountpoints&#34;&gt;&lt;code&gt;#__createMountPoints()&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;The last line of our controller makes a call to &lt;code&gt;this.__createMountPoints();&lt;/code&gt;. This line should only be present if your bot class requires webhooks. If this is the case, you will be expected to define a class member function that looks something like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  __createMountPoints() {
    this.app = express();
    // for parsing application/json
    this.app.use(bodyParser.json());
    // for parsing application/x-www-form-urlencoded
    this.app.use(bodyParser.urlencoded({ extended: true }));

    this.app.post(this.webhookEndpoint, (req, res) =&amp;gt; {
      this.__formatUpdate(req.body)

      .then((update) =&amp;gt; {
        this.__emitUpdate(update);
      }, (err) =&amp;gt; {
        err.message = `Error in __formatUpdate &amp;quot;${err.message}&amp;quot;. Please report this.`;
        this.emit(&#39;error&#39;, err);
      });

      // just letting telegram know we got the update
      res.sendStatus(200);
    });
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Very importantly, this function creates an express router &lt;code&gt;this.app&lt;/code&gt; that will be mounted onto the main &lt;code&gt;app&lt;/code&gt; router from the botmaster object if &lt;code&gt;botmaster.addBot&lt;/code&gt; is used.&lt;/p&gt;

&lt;p&gt;It then sets up the post endpoint that listens onto &lt;code&gt;this.webhookEnpoint&lt;/code&gt;. No further assumption is made here.&lt;/p&gt;

&lt;p&gt;Please note that you might have another function that needs to be called at this point. For instance, in the &lt;code&gt;socketioBot&lt;/code&gt; class, I make a call to: &lt;code&gt;this.__setupSocketioServer();&lt;/code&gt; and that function looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;__setupSocketioServer() {
  this.ioServer = io(this.server);

  this.ioServer.on(&#39;connection&#39;, (socket) =&amp;gt; {
    socket.join(SocketioBot.__getBotmasteruserId(socket));

    socket.on(&#39;message&#39;, (message) =&amp;gt; {
      // just broadcast the message to other connected clients with same user id
      const botmasterUserId = SocketioBot.__getBotmasteruserId(socket);
      socket.broadcast.to(botmasterUserId).emit(&#39;own message&#39;, message);
      // console.log(JSON.stringify(socket.rooms, null, 2));
      const rawUpdate = message;
      try {
        rawUpdate.socket = socket;
      } catch (err) {
        err.message = `ERROR: &amp;quot;Expected JSON object but got &#39;${typeof message}&#39; ${message} instead&amp;quot;`;
        return this.emit(&#39;error&#39;, err);
      }
      const update = this.__formatUpdate(rawUpdate, botmasterUserId);
      return this.__emitUpdate(update);
    });
  });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Feel free to have a thorough read at this to understand what is going on here. Because it isn&amp;rsquo;t necessary to understand this in order to build your own bot class, I won&amp;rsquo;t explain what is going on here.&lt;/p&gt;

&lt;h3 id=&#34;formatupdate-rawupdate&#34;&gt;&lt;code&gt;#__formatUpdate(rawUpdate)&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;Although you can technically handle the body of the request as you wish. In our &lt;code&gt;__createMountPoints&lt;/code&gt; example here (from TelegramBot code), we make a call to the &lt;code&gt;__formatUpdate&lt;/code&gt; function with the body of the request.
It would make sense for you to do so for consistency and because it has to be defined if you want your bot class to eventually be referenced in the Botmaster project.&lt;/p&gt;

&lt;p&gt;This function is expected to transform the &lt;code&gt;rawUpdate&lt;/code&gt; into an object which is of the format of Messenger updates, while having an &lt;code&gt;update.raw&lt;/code&gt; bit that references that &lt;code&gt;rawUpdate&lt;/code&gt; received.&lt;/p&gt;

&lt;p&gt;Typically, it would look something like this for a message with an image attachment. Independent of what platform the message comes from:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  raw: &amp;lt;platform_specific_raw_update&amp;gt;,
  sender: {
    id: &amp;lt;id_of_sender&amp;gt;
  },
  recipient: {
    id: &amp;lt;id_of_the_recipent&amp;gt; // will typically be the bot&#39;s id
  },
  timestamp: &amp;lt;unix_miliseconds_timestamp&amp;gt;,
  message: {
    mid: &amp;lt;message_id&amp;gt;,
    seq: &amp;lt;message_sequence_id&amp;gt;,
    attachments: [
      {
        type: &#39;image&#39;,
        payload: {
          url: &#39;SOME_IMAGE_URL&#39;
        }
      }
    ]
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Your function should return the update object(or a promise that resolves a formatted update object) in order to then call &lt;code&gt;__emitUpdate&lt;/code&gt; with it as a parameter.&lt;/p&gt;

&lt;h3 id=&#34;emitupdate-update&#34;&gt;&lt;code&gt;#__emitUpdate(update)&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;Like &lt;code&gt;__applySettings&lt;/code&gt;, this method is implemented in &lt;code&gt;BaseBot&lt;/code&gt;. It handles errors, calling the &lt;code&gt;incoming&lt;/code&gt; middleware stack, and most importantly, actually calling &lt;code&gt;this.emit(update)&lt;/code&gt; to emit the actual update. You can overwrite this method if you wish, but in its current state, it handles the most important cases you will want to deal with. You should call this method with the formatted &lt;code&gt;update&lt;/code&gt; object created by calling &lt;code&gt;formatUpdate()&lt;/code&gt;;&lt;/p&gt;

&lt;h3 id=&#34;sendmessage-message&#34;&gt;&lt;code&gt;#__sendMessage(message)&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;All previous methods had either something to do with object instantiation or with incoming messages. We&amp;rsquo;ll now have a look at what needs to be done within your bot class to send messages.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;__sendMessage&lt;/code&gt; method needs to be implemented. The method should take in a Messenger style message and send a formatted message to the bot platform. It should return a &lt;code&gt;Promise&lt;/code&gt; that resolves to something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  {
   raw: rawBody,
   recipient_id: &amp;lt;id_of_user&amp;gt;,
   message_id: &amp;lt;message_id_of_what_was_just_sent&amp;gt;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Code for it might look like this simplified one from &lt;code&gt;TelegramBot&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt; __sendMessage(message) {
  const options = {
    url: &#39;https://api.telegram.org/sendMessage&#39;,
    method: &#39;POST&#39;,
  };
  options.json = this.__formatOutgoingMessage(message);

  return request(options) // using request-promise package and not request here

  .then((body) =&amp;gt; {
    if (body.error) {
      throw new Error(JSON.stringify(body.error));
    }

    const standardizedBody = {
      raw: body,
      recipient_id: body.result.chat.id,
      // this is really the equivalent to a Messenger seq.
      // But it&#39;s either that or null for telegram
      message_id: body.result.message_id,
    };
    return standardizedBody;
  });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;See how we are returning a promise that resolves to an object as specified above!&lt;/p&gt;

&lt;p&gt;It is important to note that this be a promise and not a callback. Although developers using Botmaster can use &lt;code&gt;sendMessage&lt;/code&gt; type methods with callbacks. The internals of Botmaster use Promises and therefore, so should your bot class.&lt;/p&gt;

&lt;p&gt;Please note that the &lt;code&gt;BaseBot&lt;/code&gt; superclass defines a set of methods that allow developers to more easily send messages to all platforms without having to build the whole Messenger compatible object themselves. These methods are the following:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sendMessage&lt;/code&gt;
&lt;code&gt;sendMessageTo&lt;/code&gt;
&lt;code&gt;sendTextMessageTo&lt;/code&gt;
&lt;code&gt;reply&lt;/code&gt;
&lt;code&gt;sendAttachmentTo&lt;/code&gt;
&lt;code&gt;sendAttachmentFromURLTo&lt;/code&gt;
&lt;code&gt;sendDefaultButtonMessageTo&lt;/code&gt;
&lt;code&gt;sendIsTypingMessageTo&lt;/code&gt;
&lt;code&gt;sendCascadeTo&lt;/code&gt;
&lt;code&gt;sendTextCascadeTo&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;All these methods will convert a developer specified input into a Facebook Messenger compatible message that will be called as a parameter to &lt;code&gt;__sendMessage&lt;/code&gt;. That is, they all eventually will call your &lt;code&gt;__sendMessage&lt;/code&gt; method. You can however overwrite them if need be.&lt;/p&gt;

&lt;h3 id=&#34;formatoutgoingmessage-message&#34;&gt;&lt;code&gt;#__formatOutgoingMessage(message)&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;Your &lt;code&gt;sendMessage&lt;/code&gt; method is expected to call a &lt;code&gt;__formatOutgoingMessage(message)&lt;/code&gt; method that will format the Messenger style message into one that is compatible with the platform you are coding your bot class for.&lt;/p&gt;

&lt;p&gt;You can have a look at the ones defined in the &lt;code&gt;TelegramBot&lt;/code&gt; and the &lt;code&gt;TwitterBot&lt;/code&gt; classes for inspiration.&lt;/p&gt;

&lt;h3 id=&#34;setbotidifnotset-update&#34;&gt;&lt;code&gt;#__setBotIdIfNotSet(update)&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;In order to help you identify between bots of different types, you will want each bot instance to have a &lt;code&gt;this.id&lt;/code&gt; value. This should typically be the same as &lt;code&gt;update.recipient.id&lt;/code&gt; when getting updates. If these aren&amp;rsquo;t set upon instantiation (as with Facebook Messenger bots), you can write a function like this &lt;code&gt;MessengerBot&lt;/code&gt; one that gets called upon receiving a message.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;__setBotIdIfNotSet(update) {
  if (!this.id) {
  	this.id = update.recipient.id;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;is-this-really-all-there-is-to-it&#34;&gt;Is this really all there is to it?&lt;/h2&gt;

&lt;p&gt;Yes it is! These few basic steps are the steps that should be followed in order to build your own bot classes. Nothing more is required. Of course, formatting the incoming updates and the outgoing messages won&amp;rsquo;t always be as trivial as we&amp;rsquo;d wish, but this guide should help you into doing this.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Quickstart</title>
      <link>https://botmasterai.github.io/getting-started/quickstart/</link>
      <pubDate>Mon, 31 Oct 2016 21:39:47 +0000</pubDate>
      
      <guid>https://botmasterai.github.io/getting-started/quickstart/</guid>
      <description>&lt;p&gt;If you already know your credentials for the platforms you want to be supporting in your project the following code will help you get started&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
// settings stuff
const Botmaster = require(&#39;botmaster&#39;);

const botmasterSettings = {
  // by default botmaster will start an express server that listens on port 3000
  // you can pass in a port argument here to change this default setting:
  port: 3001,
}

const botmaster = new Botmaster(botmasterSettings);

// you would typically hold this information in a &amp;quot;config&amp;quot; file.
// or use environment variables
const messengerSettings = {
  credentials: {
    verifyToken: &#39;YOUR verifyToken&#39;,
    pageToken: &#39;YOUR pageToken&#39;,
    fbAppSecret: &#39;YOUR fbAppSecret&#39;,
  },
  webhookEndpoint: &#39;/webhook1234&#39;, // botmaster will mount this webhook on https://Your_Domain_Name/messenger/webhook1234
};

const twitterSettings = {
  credentials: {
    consumerKey: &#39;YOUR consumerKey&#39;,
    consumerSecret: &#39;YOUR consumerSecret&#39;,
    accessToken: &#39;YOUR accessToken&#39;,
    accessTokenSecret: &#39;YOUR accessTokenSecret&#39;,
  }
}

const telegramSettings = {
  credentials: {
    authToken: &#39;YOUR authToken&#39;,
  },
  webhookEndpoint: &#39;/webhook1234/&#39;,
};

const slackSettings = {
  credentials: {
    clientId: &#39;YOUR app client ID&#39;,
    clientSecret: &#39;YOUR app client secret&#39;,
    verificationToken: &#39;YOUR app verification Token&#39;,
    landingPageURL: &#39;YOUR landing page URL&#39; // users will be redirected there after adding your bot app to slack. If not set, they will be redirected to their standard slack chats.
  },
  webhookEndpoint: &#39;/webhook&#39;,
  storeTeamInfoInFile: true,
};

const socketioSettings = {
  id: &#39;SOME_ID_OF_YOUR_CHOOSING&#39;,
};

// instantiate new objects of the various bot classes bundled in with
// the botmaster package. Other bot class packages can be installed or
// built.
const messengerBot = new Botmaster.botTypes.MessengerBot(messengerSettings);
const slackBot = new Botmaster.botTypes.SlackBot(slackSettings);
const socketioBot = new Botmaster.botTypes.SocketioBot(socketioSettings));
const twitterBot = new Botmaster.botTypes.TwitterBot(twitterSettings);
const telegramBot = new Botmaster.botTypes.TelegramBot(telegramSettings);

botmaster.addBot(messengerBot);
botmaster.addBot(slackBot);
botmaster.addBot(socketioBot);
botmaster.addBot(twitterBot);
botmaster.addBot(telegramBot);

// actual code
botmaster.on(&#39;update&#39;, (bot, update) =&amp;gt; {
  bot.sendTextMessageTo(&#39;Right back at you!&#39;, update.sender.id);
});

botmaster.on(&#39;error&#39;, (bot, err) =&amp;gt; {
  console.log(err.stack);
  console.log(&#39;there was an error&#39;);
});
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Getting set up</title>
      <link>https://botmasterai.github.io/getting-started/getting-set-up/</link>
      <pubDate>Mon, 31 Oct 2016 22:33:42 +0000</pubDate>
      
      <guid>https://botmasterai.github.io/getting-started/getting-set-up/</guid>
      <description>

&lt;p&gt;The following will create a &lt;code&gt;botmaster&lt;/code&gt; object you will be using in the rest of your code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const Botmaster = require(&#39;botmaster&#39;);
const botmaster = new Botmaster();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You would then add support for various messaging platforms as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const somePlatformBot = new PlatformBot(platformBotSettings);
botmaster.addBot(somePlatformBot);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In practice this would look something like this for, say, Facebook Messenger:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const messengerSettings = {
  credentials: {
    verifyToken: &#39;YOUR verifyToken&#39;,
    pageToken: &#39;YOUR pageToken&#39;,
    fbAppSecret: &#39;YOUR fbAppSecret&#39;,
  },
  webhookEndpoint: &#39;/webhook1234&#39;, // botmaster will mount this webhook on https://Your_Domain_Name/messenger/webhook1234
};
const messengerBot = new Botmaster.botTypes.MessengerBot(messengerSettings);
botmaster.addBot(messengerBot);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Where you&amp;rsquo;d typically hold the settings in a &lt;code&gt;config&lt;/code&gt; file somewhere.
In order to instantiate a &lt;code&gt;Botmaster&lt;/code&gt; object, you need to pass it some settings in the form of an object. These settings look like this. See the various getting started guides for the different platforms to see both what credentials are required and how to gather them.&lt;/p&gt;

&lt;h3 id=&#34;botmastersettings&#34;&gt;botmasterSettings&lt;/h3&gt;

&lt;p&gt;You might want/need to specify the port to start botmaster on, or more generally, the express app that it should be working on (in this case you would have specified your own port separately)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const botmasterSettings = {
  app: app, // optional, an express app object if you are running your own express server
  port: port, // optional, only used if &amp;quot;app&amp;quot; is not defined. Defaults to 3000 in that case
  botsSettings: botsSettings, // optional see below for a definition of botsSettings [deprecated. Use &#39;botmaster.addBot()&#39; instead]
  server: server, // optional, an http server object (used only if using socket.io) [deprecated. add server directly to socketioSettings]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;See &lt;a href=&#34;https://botmasterai.github.io/working-with-botmaster&#34;&gt;Working with Botmaster&lt;/a&gt; for a more formal definition&lt;/p&gt;

&lt;p&gt;Once you have those &lt;code&gt;botmasterSettings&lt;/code&gt;, you would instantiate a &lt;code&gt;Botmaster&lt;/code&gt; object as such:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const botmaster = new Botmaster(botmasterSettings);
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Facebook Messenger Setup</title>
      <link>https://botmasterai.github.io/getting-started/messenger-setup/</link>
      <pubDate>Mon, 31 Oct 2016 22:24:20 +0000</pubDate>
      
      <guid>https://botmasterai.github.io/getting-started/messenger-setup/</guid>
      <description>

&lt;h2 id=&#34;code&#34;&gt;Code&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const Botmaster = require(&#39;botmaster&#39;);
const botmaster = new Botmaster();

const messengerSettings = {
  credentials: {
    verifyToken: &#39;YOUR verifyToken&#39;,
    pageToken: &#39;YOUR pageToken&#39;,
    fbAppSecret: &#39;YOUR fbAppSecret&#39;,
  },
  webhookEndpoint: &#39;/webhook1234&#39;,
};

const messengerBot = new Botmaster.botTypes.MessengerBot(messengerSettings);
botmaster.addBot(messengerBot);

botmaster.on(&#39;update&#39;, (bot, update) =&amp;gt; {
  bot.reply(update, &#39;Hello world!&#39;);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;getting-your-credentials&#34;&gt;Getting your Credentials&lt;/h2&gt;

&lt;p&gt;If you don&amp;rsquo;t already have these, follow the steps &lt;strong&gt;1-4&lt;/strong&gt; on the Facebook Messenger guide:
&lt;a href=&#34;https://developers.facebook.com/docs/messenger-platform/guides/quick-start&#34;&gt;https://developers.facebook.com/docs/messenger-platform/guides/quick-start&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;In &lt;strong&gt;step 2&lt;/strong&gt;, where you setup your webhook, no need to code anything. Just specify the webhook, enter any secure string you want as a verify token(&lt;code&gt;verifyToken&lt;/code&gt;) and copy that value in the settings object. Also, click on whichever message [those are &amp;ldquo;update&amp;rdquo;s using botmaster semantics] type you want to receive from Messenger (&lt;code&gt;message_deliveries&lt;/code&gt;, &lt;code&gt;messages&lt;/code&gt;, &lt;code&gt;message_postbacks&lt;/code&gt; etc&amp;hellip;).&lt;/p&gt;

&lt;p&gt;To find your Facebook App Secret (&lt;code&gt;fbAppSecret&lt;/code&gt;), navigate to your apps dashboard and under &lt;code&gt;App Secret&lt;/code&gt; click show, enter your password if prompted and then there it is.&lt;/p&gt;

&lt;h2 id=&#34;webhooks&#34;&gt;Webhooks&lt;/h2&gt;

&lt;div class=&#34;notices note&#34; &gt;&lt;p&gt;If you are not too sure how webhooks work and/or how to get them to run locally, go to &lt;a href=&#34;https://botmasterai.github.io/getting-started/webhooks&#34;&gt;webhooks&lt;/a&gt; to read some more.&lt;/p&gt;
&lt;/div&gt;

</description>
    </item>
    
    <item>
      <title>Slack Setup</title>
      <link>https://botmasterai.github.io/getting-started/slack-setup/</link>
      <pubDate>Mon, 31 Oct 2016 23:01:53 +0000</pubDate>
      
      <guid>https://botmasterai.github.io/getting-started/slack-setup/</guid>
      <description>

&lt;h2 id=&#34;code&#34;&gt;Code&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const Botmaster = require(&#39;botmaster&#39;);
const botmaster = new Botmaster();

const slackSettings = {
  credentials: {
    clientId: &#39;YOUR app client ID&#39;,
    clientSecret: &#39;YOUR app client secret&#39;,
    verificationToken: &#39;YOUR app verification Token&#39;
  },
  webhookEndpoint: &#39;/webhookd24sr34se&#39;,
  storeTeamInfoInFile: true,
};

const slackBot = new Botmaster.botTypes.SlackBot(slackSettings);
botmaster.addBot(slackBot);

botmaster.on(&#39;update&#39;, (bot, update) =&amp;gt; {
  bot.reply(update, &#39;Hello world!&#39;);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;the-botmaster-slack-bot&#34;&gt;The Botmaster Slack bot&lt;/h2&gt;

&lt;p&gt;Because Slack works slightly differently from the other platforms covered in the core Botmaster package, I will briefly explain here what your botmaster Slack bot will be exactly.&lt;/p&gt;

&lt;p&gt;As you surely know, Slack is a product that enables team members to communicate easily with one another. because of that, one team member can&amp;rsquo;t just &amp;ldquo;add&amp;rdquo; a bot for herself in the same way one would in Facebook Messenger or Telegram or other.&lt;/p&gt;

&lt;p&gt;Teams can either build a bot that will only live within their own slack team. Or they can package a bot in a Slack app that &amp;ldquo;packages&amp;rdquo; the bot.
Admin team members can add support for a bot (by installing an App that packages said bot) and then team members can start communicating with it as they would with another team member. At this point, they would be communicating with what is known as, in Slack semantics, a &lt;strong&gt;bot user&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;slackSettings&lt;/code&gt; object is required to allow us to communicate to end users via this &lt;strong&gt;bot user&lt;/strong&gt; that needs to be set up on Slack&amp;rsquo;s end.&lt;/p&gt;

&lt;h2 id=&#34;botmaster-slack-bot-mini-tutorial&#34;&gt;Botmaster Slack bot mini-tutorial&lt;/h2&gt;

&lt;p&gt;Following these steps, you will have a fully functional Slack bot using botmaster that can then be edited as wanted. This mini-tutorial uses localtunnel to expose one of your ports to the world. see why you might want to use this and how to install and setup localtunnel &lt;a href=&#34;https://botmasterai.github.io/getting-started/webhooks#localtunnel&#34;&gt;here&lt;/a&gt;for your local botmaster project. You can use ngrok or any other service you know or find suitable and achieve the same result.&lt;/p&gt;

&lt;h4 id=&#34;create-an-app&#34;&gt;Create an app&lt;/h4&gt;

&lt;p&gt;Navigate to: &lt;a href=&#34;https://api.slack.com/apps&#34;&gt;https://api.slack.com/apps&lt;/a&gt; and make sure you are signed in. If you aren&amp;rsquo;t you will be redirected to your team&amp;rsquo;s slack once logged in and will need to go back to the mentioned link.&lt;/p&gt;

&lt;p&gt;Click the &lt;strong&gt;create new App&lt;/strong&gt; button and enter any App Name you want. This won&amp;rsquo;t be the name of the &lt;strong&gt;bot user&lt;/strong&gt;. However, the name should ideally be related to your bot user so as not to confuse your users. For instance, if your bot user will be called &lt;em&gt;my_super_bot&lt;/em&gt;, calling the app something like &lt;em&gt;My Super Bot App&lt;/em&gt; would make sense.&lt;/p&gt;

&lt;h4 id=&#34;get-your-first-credentials&#34;&gt;Get your first credentials&lt;/h4&gt;

&lt;p&gt;On this page you were redirected to, you will find an &lt;em&gt;App credentials&lt;/em&gt; section. Both your Client ID (&lt;code&gt;clientId&lt;/code&gt; in Botmaster) and your Client Secret (&lt;code&gt;clientSecret&lt;/code&gt; in Botmaster) are here. Take note of them.&lt;/p&gt;

&lt;h4 id=&#34;setup-your-app-s-oauth-webhook&#34;&gt;Setup Your App&amp;rsquo;s OAuth Webhook&lt;/h4&gt;

&lt;p&gt;You don&amp;rsquo;t need to know anything about OAuth to complete this step. Just know that this URL will be called when people are installing/authorizing your app.&lt;/p&gt;

&lt;p&gt;In the left panel, click on the &lt;strong&gt;OAuth &amp;amp; Permissions&lt;/strong&gt; tab and enter your webhook in the &lt;strong&gt;Redirect URL(s)&lt;/strong&gt; field as shown here:
    &lt;img src=&#34;https://botmasterai.github.io/images/slack_setup_1.png?width=90%&#34; alt=&#34;Slack Setup 1&#34; /&gt;
This URL has to be of the form: &lt;strong&gt;https://&amp;lt;your_base_url&amp;gt;/slack/&amp;lt;webhookEndpoint&amp;gt;&lt;/strong&gt;. For example, &lt;strong&gt;if&lt;/strong&gt; I am using localtunnel to test the bot locally, and started localtunnel by running the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;  lt -p 3000 -s botmastersubdomain
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I would set my Redirect URL(s) to: &lt;code&gt;https://botmastersubdomain.localtunnel.me/slack/webhookd24sr34se&lt;/code&gt; (based on the &lt;code&gt;webhookEnpoint&lt;/code&gt; set in my &lt;code&gt;slackSettings&lt;/code&gt; at the top of this page). Click on &lt;strong&gt;Save Changes&lt;/strong&gt;.&lt;/p&gt;

&lt;h4 id=&#34;add-a-bot-user&#34;&gt;Add a Bot User&lt;/h4&gt;

&lt;p&gt;Go to &lt;strong&gt;Bot Users&lt;/strong&gt; and click on the &lt;strong&gt;Add a Bot User&lt;/strong&gt; button. Select a name for your bot (e.g. my_super_bot) and click the &lt;strong&gt;Add Bot User&lt;/strong&gt; button.&lt;/p&gt;

&lt;h4 id=&#34;get-the-rest-of-your-credentials&#34;&gt;Get the rest of your credentials&lt;/h4&gt;

&lt;p&gt;Navigate to the &lt;strong&gt;Event Subscriptions&lt;/strong&gt; tab and click on the toggle button in the to right corner to &lt;strong&gt;on&lt;/strong&gt;. Then in the &lt;strong&gt;Request URL&lt;/strong&gt; field that pops up, enter the same URL as in step 4. &lt;strong&gt;You will get an error&lt;/strong&gt;. This is normal and is due to two reasons. Firstly, we don&amp;rsquo;t actually have an app started and listening at the mentioned URL and secondly because even if we did, we don&amp;rsquo;t have our App&amp;rsquo;s verification Token. Let&amp;rsquo;s fix this!&lt;/p&gt;

&lt;p&gt;Navigate back to &lt;strong&gt;Basic Information&lt;/strong&gt; and note that you now have a &lt;strong&gt;Verification Token&lt;/strong&gt; in the App Credentials box. Take note of it.&lt;/p&gt;

&lt;h4 id=&#34;start-your-botmaster-app-locally&#34;&gt;Start your Botmaster App Locally&lt;/h4&gt;

&lt;p&gt;Start your botmaster app in any project folder you might want (see &lt;a href=&#34;https://botmasterai.github.io/getting-started/installation&#34;&gt;here&lt;/a&gt; if you haven&amp;rsquo;t installed botmaster yet). To start the botmaster project, you&amp;rsquo;ll want to create an &lt;code&gt;app.js&lt;/code&gt; file with the contents from the &lt;a href=&#34;http://localhost:1313/getting-started/slack-setup/#code&#34;&gt;code&lt;/a&gt; at the top of this page in the root of your project folder. Replace the credentials with the ones you have gathered. Run &lt;code&gt;node app.js&lt;/code&gt; to start the app. Let&amp;rsquo;s now expose out bot to the world.&lt;/p&gt;

&lt;p&gt;For the webhook to work locally, you&amp;rsquo;ll now need to make sure you&amp;rsquo;ve started localtunnel. If you are doing all of that from a server that already has a Domain Name, you won&amp;rsquo;t need to do this. But I am assuming most people are doing this from their local computer. so in the command line, run something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;lt -p 3000 -s &amp;lt;wanted_base_url_for_your_bot&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;setup-your-app-s-events-and-events-webhook&#34;&gt;Setup Your App&amp;rsquo;s Events and Events Webhook&lt;/h4&gt;

&lt;p&gt;Go back to the &lt;strong&gt;Event subscription&lt;/strong&gt; page and enter your webhook url again. This should now work and look something like this: &lt;img src=&#34;https://botmasterai.github.io/images/slack_setup_2.png?width=90%&#34; alt=&#34;Slack Setup 2&#34; /&gt; Scroll down and click on &lt;strong&gt;Add Bot User Events&lt;/strong&gt;. At the minimum, add the following events:
    * message.ipm
    * message.channels
    * message.im
    * message.groups
Click &lt;strong&gt;Save Changes&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&#34;install-your-slack-app&#34;&gt;Install your Slack App&lt;/h4&gt;

&lt;p&gt;We&amp;rsquo;re almost done here. We need a way to install our app to test it out. This is done via what is called a &lt;strong&gt;Slack button&lt;/strong&gt;. because botmaster manages all the nitty-gritty parts of this process, all you need to do is create a &lt;code&gt;views&lt;/code&gt; folder in your project folder and create an &lt;code&gt;index.html&lt;/code&gt; file in this views folder with the following contents&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;a href=&amp;quot;https://slack.com/oauth/authorize?scope=bot&amp;amp;client_id=YOUR_APP_CLIENT_ID&amp;quot;&amp;gt;
  &amp;lt;img alt=&amp;quot;Add to Slack&amp;quot; height=&amp;quot;40&amp;quot; width=&amp;quot;139&amp;quot;
  src=&amp;quot;https://platform.slack-edge.com/img/add_to_slack.png&amp;quot;
  srcset=&amp;quot;https://platform.slack-edge.com/img/add_to_slack.png 1x,
          https://platform.slack-edge.com/img/add_to_slack@2x.png 2x&amp;quot; /&amp;gt;
&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that you&amp;rsquo;ll need to replace &lt;strong&gt;YOUR_APP_CLIENT_ID&lt;/strong&gt; in the href with your own. You definitely don&amp;rsquo;t want to put in your client secret here!&lt;/p&gt;

&lt;h4 id=&#34;try-out-your-bot&#34;&gt;Try out your bot!&lt;/h4&gt;

&lt;p&gt;Assuming your botmaster app and localtunnel are still running, open your &lt;code&gt;index.html&lt;/code&gt; file (not in a text editor, but actually in a browser) by double clicking on it. Authorize your newly created app to add it to your team. You should now be redirected to your teams slack and be able to chat to your bot.&lt;/p&gt;

&lt;h4 id=&#34;make-your-bot-available-to-the-world&#34;&gt;Make your Bot Available to the World&lt;/h4&gt;

&lt;p&gt;You might actually want to allow others to install your app by using the Slack Button. However, to do so you will need to host it somewhere. We&amp;rsquo;ll take advantage of the fact that botmaster uses express.js under the hood and edit our app.js file to look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const Botmaster = require(&#39;botmaster&#39;);
const express = require(&#39;express&#39;); // added
.
.
.
botmaster.app.use(express.static(__dirname + &#39;/views&#39;)); //added
// or if you don&#39;t want it at the root of your app, add this:
botmaster.app.use(&#39;/slack&#39;, express.static(__dirname + &#39;/views&#39;)); // added

botmaster.on(&#39;update&#39;, (bot, update) =&amp;gt; {
  bot.reply(update, &#39;Right back at you&#39;);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Make sure to add either one of the &lt;code&gt;botmaster.app.use...&lt;/code&gt; lines.
If you pick the first one, navigate to your URL (&lt;code&gt;https://botmastersubdomain.localtunnel.me/&lt;/code&gt; for this example) and you will see the button.
If your pick the second one, navigate to your sub URL (&lt;code&gt;https://botmastersubdomain.localtunnel.me/slack&lt;/code&gt; for this example) to see the Slack button.&lt;/p&gt;

&lt;h2 id=&#34;webhooks&#34;&gt;Webhooks&lt;/h2&gt;

&lt;p&gt;Now as with any other platform using Webhooks, you&amp;rsquo;ll need to update these to your production Domain Name once you deploy your code to production. And in a more general sense, if you are still unsure how webhooks work within the botmaster framework, go &lt;a href=&#34;https://botmasterai.github.io/getting-started/webhooks&#34;&gt;here&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Socket.io Setup</title>
      <link>https://botmasterai.github.io/getting-started/socketio-setup/</link>
      <pubDate>Wed, 02 Nov 2016 18:18:34 +0000</pubDate>
      
      <guid>https://botmasterai.github.io/getting-started/socketio-setup/</guid>
      <description>

&lt;h2 id=&#34;code&#34;&gt;Code&lt;/h2&gt;

&lt;h4 id=&#34;server&#34;&gt;Server&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const Botmaster = require(&#39;botmaster&#39;);
const botmaster = new Botmaster();

const socketioSettings = {
  id: &#39;SOME_BOT_ID_OF_YOUR_CHOOSING&#39;,
  server: botmaster.server, // this is required for socket.io. You can set it to another node server object if you wish to. But in this example, we will use the one created by botmaster under the hood
};

const socketioBot = new Botmaster.botTypes.SocketioBot(socketioSettings);
botmaster.addBot(socketioBot);

botmaster.on(&#39;update&#39;, (bot, update) =&amp;gt; {
  bot.reply(update, &#39;Right back at you&#39;);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;client&#34;&gt;Client&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const io = require(&#39;socket.io-client&#39;);

const socket = io(&#39;ws://localhost:3000&#39;);

socket.on(&#39;connect&#39;, function() {
  const message = {
    text: &#39;Hey there botmaster!&#39;
  };

  socket.send(JSON.stringify(message));
});

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;the-botmaster-socket-io-bot&#34;&gt;The Botmaster Socket.io bot&lt;/h2&gt;

&lt;p&gt;Socket.io is a great library that allows developers to write apps using webSockets (with fallbacks to http long-polling and others when webSockets aren&amp;rsquo;t available on the client). You can read more about it on their own website here: &lt;a href=&#34;http://socket.io&#34;&gt;http://socket.io&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Because you might want to have a bot that not only works on some arbitrary platform but also on your own webapp/app, support for socket.io was added to the Botmaster core. Although Socket.io enables developers to use their technology in a bunch of different applications, the fact that you want to use it in Botmaster means that you want to handle 1-1 conversations between users and your bot (managed by botmaster).&lt;/p&gt;

&lt;p&gt;If you&amp;rsquo;ve never used both botmaster and socket.io, It&amp;rsquo;s probably still pretty unclear how all of this fits in together. Hopefully the next section will help you understand and get started with this.&lt;/p&gt;

&lt;h2 id=&#34;botmaster-socket-io-bot-mini-tutorial&#34;&gt;Botmaster Socket.io bot mini-tutorial&lt;/h2&gt;

&lt;p&gt;By following these steps, you will have a fully functional Socket.io bot using botmaster. The client will live in a tiny web-page. The point of this tutorial is to get you started so that you can develop it further in any way you wish. This is completely based on the socket.io web &amp;ldquo;get started&amp;rdquo; guide found here: &lt;a href=&#34;http://socket.io/get-started/chat/&#34;&gt;http://socket.io/get-started/chat/&lt;/a&gt;.&lt;/p&gt;

&lt;h4 id=&#34;server-1&#34;&gt;Server&lt;/h4&gt;

&lt;p&gt;After making sure that we have a project folder with a node.js project initialised and the botmaster package in it as per the &lt;a href=&#34;https://botmasterai.github.io/getting-started/installation&#34;&gt;installation&lt;/a&gt; guide.
We want to make sure botmaster is setup and make sure that messages coming from a websocket connection are received. So in our poject folder, in our &lt;code&gt;app.js&lt;/code&gt; file, we simply copy the code found at the top of this page:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const Botmaster = require(&#39;botmaster&#39;);

const botmaster = new Botmaster();

const socketioSettings = {
  id: &#39;SOME_BOT_ID_OF_YOUR_CHOOSING&#39;,
  server: botmaster.server,
};

const socketioBot = new Botmaster.botTypes.SocketioBot(socketioSettings);
botmaster.addBot(socketioBot);

botmaster.on(&#39;update&#39;, (bot, update) =&amp;gt; {
  bot.reply(update, &#39;Right back at you&#39;);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We will need to add a couple of lines to this code because we will be serving a webpage from our server. Not just listening on for botmaster messages. To do so, we take advantage of the fact that botmaster is built on top of express and that this app es exposed via &lt;code&gt;botmaster.app&lt;/code&gt;. We also assume that we will be serving our static assets (the components of our webpage) from a folder called &amp;lsquo;public&amp;rsquo; within our project directory. Our updated code looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const express = require(&#39;express&#39;); //added
const Botmaster = require(&#39;botmaster&#39;);

const botmaster = new Botmaster();
botmaster.app.use(express.static(`${__dirname}/public`)); //added


const socketioSettings = {
  id: &#39;SOME_BOT_ID_OF_YOUR_CHOOSING&#39;,
  server: botmaster.server,
};

const socketioBot = new Botmaster.botTypes.SocketioBot(socketioSettings);
botmaster.addBot(socketioBot);

botmaster.on(&#39;update&#39;, (bot, update) =&amp;gt; {
  bot.reply(update, &#39;Right back at you&#39;);
});

botmaster.on(&#39;error&#39;, (bot, err) =&amp;gt; {
  console.log(err.stack);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We also added the botmaster &amp;lsquo;error&amp;rsquo; event listener, because that&amp;rsquo;s just always good to do.&lt;/p&gt;

&lt;h3 id=&#34;client-side&#34;&gt;Client side&lt;/h3&gt;

&lt;p&gt;As mentioned in the Server side, we will create a folder named &amp;lsquo;public&amp;rsquo; within our poject dir. In it, we will have the following three files:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;index.html&lt;/li&gt;
&lt;li&gt;style.css&lt;/li&gt;
&lt;li&gt;client_app.js&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So that your final tree structure looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;your_project_folder
 app.js
 public
     client_app.js
     index.html
     style.css
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the &lt;code&gt;index.html&lt;/code&gt; file, we will put some very basic html that looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!doctype html&amp;gt;
&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;Botmaster bot&amp;lt;/title&amp;gt;
    &amp;lt;link rel=&amp;quot;stylesheet&amp;quot; type=&amp;quot;text/css&amp;quot; href=&amp;quot;style.css&amp;quot;&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;div class=&amp;quot;chat&amp;quot;&amp;gt;
      &amp;lt;ul id=&amp;quot;messages&amp;quot;&amp;gt;&amp;lt;/ul&amp;gt;
      &amp;lt;form id=&amp;quot;form&amp;quot; action=&amp;quot;&amp;quot;&amp;gt;
        &amp;lt;input type=&amp;quot;text&amp;quot; id=&amp;quot;text-input&amp;quot; autocomplete=&amp;quot;off&amp;quot; /&amp;gt;&amp;lt;button&amp;gt;Send&amp;lt;/button&amp;gt;
      &amp;lt;/form&amp;gt;
    &amp;lt;/div&amp;gt;

    &amp;lt;script src=&amp;quot;/socket.io/socket.io.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&amp;quot;client_app.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The important line here is the line where we are importing socket.io. This works because socket.io adds a path to our server (in this case, a server created by botmaster under the hood) to serve this exact endpoint.
The other imports are simply the ones we will be creating.&lt;/p&gt;

&lt;p&gt;In the &lt;code&gt;style.css&lt;/code&gt; file, simply add the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;* {
  margin: 0;
  padding: 0;
  box-sizing:
  border-box;
}

body {
  font: 13px Helvetica, Arial;
}

form {
  background: #000;
  padding: 3px;
  position: fixed;
  bottom: 0;
  width: 100%;
}

form input {
  border: 0;
  padding: 10px;
  width: 90%;
  margin-right: .5%;
}

form button {
  width: 9%; background: rgb(130, 224, 255);
  border: none; padding: 10px;
}

#messages {
  list-style-type: none;
  margin: 0;
  padding: 0;
}

#messages li {
  padding: 5px 10px;
}

#messages .botmaster-message {
  background: #eee;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is the exact look from the socket.io tutorial mentioned above (and mostly their code too).&lt;/p&gt;

&lt;p&gt;Finally, in the &lt;code&gt;client_app.js&lt;/code&gt; file, you should include the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// the following line could also be: &amp;quot;var socket = io(&#39;ws://&amp;lt;URL&amp;gt;:&amp;lt;PORT_Number&amp;gt;?botmasterUserId=wantedUserId&#39;);&amp;quot;
// if you know you will be communicating with a server different from the one that served you the page you are on.
// this only works because the socket.io library assumes with this syntax that the socket.io server
// lives at the same address as the server that served this page (this should mostly be your case)
var socket = io(&#39;?botmasterUserId=wantedUserId&#39;);

// just get the html elements we will be needing by ID
var form = document.getElementById(&#39;form&#39;);
var textInput = document.getElementById(&#39;text-input&#39;);
var messages = document.getElementById(&#39;messages&#39;);

form.onsubmit = function(event) {
  // just making sure the page isn&#39;t refreshed
  event.preventDefault();
  // don&#39;t do anything if there is no text
  if (!textInput.value) {
    return;
  }
  // Add the user message to the web page
  messages.insertAdjacentHTML(&#39;beforeend&#39;,
    `&amp;lt;li class=&amp;quot;user-message&amp;quot;&amp;gt;${textInput.value}&amp;lt;/li&amp;gt;`);
  // create a botmaster compatible message from the text input by the user
  const message = {
    text: textInput.value,
  };
  // send the message over the webSocket
  socket.send(message);
  // finally, clear the user textInput field
  textInput.value = &#39;&#39;;
};

socket.on(&#39;message&#39;, function(botmasterMessage){
  var textMessage = botmasterMessage.message.text;

  messages.insertAdjacentHTML(&#39;beforeend&#39;,
    `&amp;lt;li class=&amp;quot;botmaster-message&amp;quot;&amp;gt;${textMessage}&amp;lt;/li&amp;gt;`);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You should have a read through this code to make sure you understand it as that is the code communicating with our botmaster backend.&lt;/p&gt;

&lt;p&gt;On the first line, we call: &lt;code&gt;var socket = io(&#39;?botmasterUserId=wantedUserId&#39;);&lt;/code&gt;. This effectively opens up a socket connection with our backend by making a request to something like this: &lt;code&gt;io(&#39;ws://localhost:3000?botmasterUserId=wantedUserId&#39;);&lt;/code&gt;. Here as you can see, we are setting a query param called &lt;strong&gt;botmasterUserId&lt;/strong&gt; to &amp;ldquo;wantedUserId&amp;rdquo;. This is done because we want to make sure that when we are getting updates in our backend, the &lt;code&gt;update.sender.id&lt;/code&gt; part will be what we set it to here and not anything else (by default the randomly allocated socket.id value). This is even more important when your users can connect from different clients and you want to make sure the botmaster reply is propagated to all the clients.&lt;/p&gt;

&lt;p&gt;In the &lt;code&gt;form.onsubmit&lt;/code&gt; part, we make sure that the text contained in the input cell is correctly formatted then sent to botmaster via the websocket. We also make sure to display it in our page and to then clear the input.&lt;/p&gt;

&lt;p&gt;In the &lt;code&gt;socket.on(&#39;message&#39;)&lt;/code&gt; part, we simply display the received message.&lt;/p&gt;

&lt;p&gt;Now that our code is here, simply go to your command line and run &lt;code&gt;node app.js&lt;/code&gt;. If you now open a browser to 127.0.0.1:3000 you should be able to chat with your pretty useless (for now) bot. Just like this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://botmasterai.github.io/images/socket.io_setup_1.png?width=90%&#34; alt=&#34;Socket.io Setup 1&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;security&#34;&gt;Security&lt;/h2&gt;

&lt;p&gt;You might be wondering how you can secure your Botmaster socket.io app. I.e. how can you make sure that a client connecting with a certain id really is who they claim they are. Well, this part is actually left to you, the developer to do. I didn&amp;rsquo;t want to make any assumptions with regards to what people would want to use to secure their app. So what I do is expose the &lt;code&gt;socket.io&lt;/code&gt; server object through the bot object. It can be accessed in the following way&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;socketioBot.ioServer
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then you&amp;rsquo;ll be able to register a middleware function to your socker.io server as such:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;socketioBot.ioServer.use((socket, next) =&amp;gt; {
  if (socket.request.headers.cookie) return next();
  next(new Error(&#39;Authentication error&#39;));
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is shamelessly stolen from the socket.io documentation here: &lt;a href=&#34;http://socket.io/docs/server-api/#namespace#use(fn:function):namespace&#34;&gt;http://socket.io/docs/server-api/#namespace#use(fn:function):namespace&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This function will be executed every time there is an incoming socket connection. Indeed, no need to do so on every message as once the connection is made, all transfers are secured on the open socket. That&amp;rsquo;s really the whole point of webSockets.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Twitter Setup</title>
      <link>https://botmasterai.github.io/getting-started/twitter-setup/</link>
      <pubDate>Fri, 04 Nov 2016 00:57:53 +0000</pubDate>
      
      <guid>https://botmasterai.github.io/getting-started/twitter-setup/</guid>
      <description>

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const Botmaster = require(&#39;botmaster&#39;);
const botmaster = new Botmaster();

const twitterSettings = {
  credentials: {
    consumerKey: &#39;YOUR consumerKey&#39;,
    consumerSecret: &#39;YOUR consumerSecret&#39;,
    accessToken: &#39;YOUR accessToken&#39;,
    accessTokenSecret: &#39;YOUR accessTokenSecret&#39;,
  }
}

const twitterBot = new Botmaster.botTypes.TwitterBot(twitterSettings);
botmaster.addBot(twitterBot);

botmaster.on(&#39;update&#39;, (bot, update) =&amp;gt; {
  bot.reply(update, &#39;Right back at you&#39;);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;getting-your-credentials&#34;&gt;Getting your Credentials&lt;/h2&gt;

&lt;p&gt;Twitter&amp;rsquo;s setup is slightly more tricky than one would wish. Because Twitter requires you to create an actual account and not a page or a bot, you&amp;rsquo;ll have to do a few more steps.&lt;/p&gt;

&lt;h4 id=&#34;setting-up-the-bot-account&#34;&gt;Setting up the bot account&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Just create a standard twitter account as you would any other. Name it as you want.&lt;/li&gt;
&lt;li&gt;navigate to your security and privacy settings (click on your image profile &amp;gt; settings &amp;gt; privacy and security settings)&lt;/li&gt;
&lt;li&gt;scroll to the bottom of the page and make sure &amp;ldquo;Receive Direct Messages from anyone&amp;rdquo; is ticked. (currently this has to be done because of Twitter&amp;rsquo;s rules concerning DMs, where in order to send a DM to someone, they have to be following you).&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;setting-up-the-app&#34;&gt;Setting up the app&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Navigate to the somewhat hard to find Twitter developer app dashboard at: &lt;a href=&#34;https://apps.twitter.com/&#34;&gt;https://apps.twitter.com/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Click Create New App. Enter your details (callback URL is not required if you are starting from scratch here). &amp;lsquo;Website&amp;rsquo; can take in a placeholder like (&lt;a href=&#34;http://www.example.com&#34;&gt;http://www.example.com&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Now navigate straight to the &amp;lsquo;Permissions&amp;rsquo; tab(do this before going to the &amp;lsquo;Keys and Access Tokens&amp;rsquo; tab). Select &amp;lsquo;Read, Write and Access direct messages&amp;rsquo; and then click &amp;lsquo;Update Setting&amp;rsquo;&lt;/li&gt;
&lt;li&gt;Navigate to the &amp;lsquo;Keys and Access Tokens&amp;rsquo; tab. You&amp;rsquo;ll find your consumerKey and consumerSecret right here&lt;/li&gt;
&lt;li&gt;Scroll down and click on &amp;lsquo;Create my access token&amp;rsquo;. You now have your accessToken  and your accessTokenSecret&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;! Makes sure not to create your access token before having reset your permissions. If you do that, you will need to change your permissions then regenerate your access token.&lt;/p&gt;

&lt;p&gt;That should about do it. Because twitter DM is not completely separate from the rest of Twitter, it behaves quite differently from the other platforms on many aspects. These points are covered in &lt;a href=&#34;https://botmasterai.github.io/working-with-botmaster&#34;&gt;working with botmaster&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Telegram Setup</title>
      <link>https://botmasterai.github.io/getting-started/telegram-setup/</link>
      <pubDate>Fri, 04 Nov 2016 01:04:24 +0000</pubDate>
      
      <guid>https://botmasterai.github.io/getting-started/telegram-setup/</guid>
      <description>

&lt;h2 id=&#34;code&#34;&gt;Code&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const Botmaster = require(&#39;botmaster&#39;);
const botmaster = new Botmaster();

const telegramSettings = {
  credentials: {
    authToken: &#39;YOUR authToken&#39;,
  },
  webhookEndpoint: &#39;/webhook1234/&#39;,
};

const telegramBot = new Botmaster.botTypes.TelegramBot(telegramSettings);
botmaster.addBot(telegramBot);

botmaster.on(&#39;update&#39;, (bot, update) =&amp;gt; {
  bot.reply(update, &#39;Right back at you&#39;);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;credentials&#34;&gt;Credentials&lt;/h2&gt;

&lt;p&gt;All you need here is an authToken. In order to get one, you will need to either create a new bot on telegram.&lt;/p&gt;

&lt;p&gt;Basically, you&amp;rsquo;ll need to send a &lt;code&gt;/newbot&lt;/code&gt; command(message) to Botfather (go talk to him &lt;a href=&#34;https://web.telegram.org/#/im?p=@BotFather&#34;&gt;here&lt;/a&gt;). Once you&amp;rsquo;re done with giving it a name and a username, BotFather will come back to you with your authToken. Make sure to store it somewhere. More info on BotFather can be found &lt;a href=&#34;https://core.telegram.org/bots#create-a-new-bot&#34;&gt;here&lt;/a&gt; if needed.&lt;/p&gt;

&lt;p&gt;For more on Telegram, you can find the telegram api docs &lt;a href=&#34;https://core.telegram.org/bots/api&#34;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;webhooks&#34;&gt;Webhooks&lt;/h2&gt;

&lt;p&gt;Setting up your webhook requires you to make the following request outside of Botmaster (using curl for instance or a browser):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;https://api.telegram.org/bot&amp;lt;authToken&amp;gt;/setWebhook?url=&amp;lt;&#39;Your Base URL&#39;&amp;gt;/telegram/webhook1234
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;notices warning&#34; &gt;&lt;p&gt;Because Telegram doesn&amp;rsquo;t send any type of information to verify the identity of the origin of the update, it is highly recommended that you include a sort of hash in your webhookEndpoint. I.e., rather than having this: &lt;code&gt;webhookEndpoint: &#39;/webhook/&#39;&lt;/code&gt;, do something more like this: &lt;code&gt;webhookEndpoint: &#39;/webhook92ywrnc9qm4qoiuthecvasdf42FG/&#39;&lt;/code&gt;. This will assure that you know where the request is coming from.&lt;/p&gt;
&lt;/div&gt;


&lt;div class=&#34;notices note&#34; &gt;&lt;p&gt;If you are not too sure how webhooks work and/or how to get them to run locally, go to &lt;a href=&#34;https://botmasterai.github.io/getting-started/webhooks&#34;&gt;webhooks&lt;/a&gt; to read some more.&lt;/p&gt;
&lt;/div&gt;

</description>
    </item>
    
    <item>
      <title>Webhooks</title>
      <link>https://botmasterai.github.io/getting-started/webhooks/</link>
      <pubDate>Thu, 17 Nov 2016 15:28:40 +0000</pubDate>
      
      <guid>https://botmasterai.github.io/getting-started/webhooks/</guid>
      <description>

&lt;p&gt;Most platforms rely on webhooks to work. As such, you are expected to setup webhooks on the various platforms that use them in order to use Botmaster with these platforms. In the &amp;lsquo;Getting started&amp;rsquo; part of this documentation, we briefly touched onto that for Telegram and Messenger and more deeply for Slack.&lt;/p&gt;

&lt;p&gt;If you are still unsure what webhooks are and how they work, within the context of chatbots, they are simply a URL provided by you pointing to where you expect messages and other updates to come in.&lt;/p&gt;

&lt;p&gt;Any platform that requires webhooks won&amp;rsquo;t work without a webhookEndpoint parameter in their settings. E.g. for Telegram:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const telegramSettings = {
  credentials: {
    authToken: &#39;YOUR authToken&#39;,
  },
  webhookEndpoint: &#39;/webhook1234/&#39;,
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will mount your telegram webhook on: &lt;code&gt;https://Your_Domain_Name:3000/messenger/webhook1234&lt;/code&gt;. And yes, you will need ssl in order to work with most platforms.&lt;/p&gt;

&lt;p&gt;As an added layer of security, it is highly recommended that you include a sort of a code in your webhookEndpoint. I.e., rather that having this: &lt;code&gt;webhookEndpoint: &#39;/webhook/&#39;&lt;/code&gt;, do something more like this: &lt;code&gt;webhookEndpoint: &#39;/webhook92ywrnc9qm4qoiuthecvasdf42FG/&#39;&lt;/code&gt;. This will assure that you know where the request is coming from. It is more important on Telegram than on other platforms as Telegram doesn&amp;rsquo;t give us any way to verify the source of the message.&lt;/p&gt;

&lt;p&gt;Now we realize you will want to develop and test your code without always deploying to a server with a valid url that supports ssl.&lt;/p&gt;

&lt;h3 id=&#34;on-a-local-machine&#34;&gt;On a local machine:&lt;/h3&gt;

&lt;p&gt;We recommend using the great localtunnel tool that proxies one of your ports to their url (with a potential wanted subdomain) using ssh.&lt;/p&gt;

&lt;p&gt;Simply install localtunnel on local machine:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;npm install -g localtunnel
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then run the localtunnel with a predetermined subdomain. e.g:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;lt -p 3000 -s botmastersubdomain //for example
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;-p&lt;/code&gt; is the port and &lt;code&gt;-s&lt;/code&gt; is the subdomain we want.
&lt;code&gt;-l&lt;/code&gt; is for the localhost we want to point to. This is useful is you are using botmaster inside of a container. For instance if using docker-machine, simply &lt;code&gt;-l&lt;/code&gt; to your docker-machines ip and &lt;code&gt;-p&lt;/code&gt; to the port that your container exposes.&lt;/p&gt;

&lt;p&gt;In the example above, url will be: &lt;code&gt;http://botmastersubdomain.localtunnel.me&lt;/code&gt;. Localtunnel is great and supports both ssl and non ssl request, which means we will actually wan to use: &lt;code&gt;https://botmastersubdomain.localtunnel.me&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;So if you specified your messenger&amp;rsquo;s bot webhook endpoint to, say, /webhook1234/, you will have to set up the webhook for your demo app at:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;https://botmastersubdomain.localtunnel.me/messenger/webhook1234/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For Telegram, it would look something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;https://botmastersubdomain.localtunnel.me/telegram/webhook1234/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you keep on getting an error that looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;your url is: https://customname.localtunnel.me
/usr/local/lib/node_modules/localtunnel/bin/client:58
        throw err;
        ^

Error: connection refused: localtunnel.me:44404 (check your firewall settings)
    at Socket.&amp;lt;anonymous&amp;gt; (/usr/local/lib/node_modules/localtunnel/lib/TunnelCluster.js:47:32)
    at emitOne (events.js:96:13)
    at Socket.emit (events.js:188:7)
    at emitErrorNT (net.js:1272:8)
    at _combinedTickCallback (internal/process/next_tick.js:74:11)
    at process._tickCallback (internal/process/next_tick.js:98:9)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is due to a bug in localtunnel. You can either go try out ngrok (which you will have to pay for), or try this workaround in the terminal:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;(while true; do
  lt -p 3000 -s botmastersubdomain
done)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;( while true; do lt -p 3000 -s botmastersubdomain; done; )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you prefer a one liner.&lt;/p&gt;

&lt;p&gt;This will just restart the process whenever it crashes (which can happen very often&amp;hellip;), making sure your webhook will always be up and listening for incoming requests.&lt;/p&gt;

&lt;p&gt;What I do in my projects is the following:&lt;/p&gt;

&lt;p&gt;Install localtunnel in the project and save to dev-dependencies&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;npm install --save-dev localtunnel
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then in my &lt;code&gt;package.json&lt;/code&gt;, add something like this in my &amp;lsquo;scripts&amp;rsquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;&amp;quot;scripts&amp;quot;: {
  .
  .
  &amp;quot;tunnel&amp;quot;: &amp;quot;( while true; do lt -p 3000 -s botmastersubdomain; done; )&amp;quot;,
  .
  .
},
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I can then simply run the runnel as follows (most likely in another console tab):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;npm run tunnel
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>